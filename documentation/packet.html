<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>packet API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>packet</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import hashlib
from hmac import sign
from ssb_util import to_var_int


class PacketType:
    &#34;&#34;&#34;
    Enum containing different packet types
    (as defined in tiny-ssb protocol).
    &#34;&#34;&#34;

    plain48 = bytes([0x00])  # sha256 HMAC signature, signle packet with 48B
    chain20 = bytes([0x01])  # sha256 HMAC signature, start of hash sidechain
    ischild = bytes([0x02])  # metafeed information, only in genesis block
    iscontn = bytes([0x03])  # metafeed information, only in genesis block
    mkchild = bytes([0x04])  # metafeed information
    contdas = bytes([0x05])  # metafeed information


class Blob:
    &#34;&#34;&#34;
    Simple class for handeling blob information.
    Not used for first blob entry (Packet).
    &#34;&#34;&#34;

    def __init__(self, payload: bytes, ptr: bytes):
        self.payload = payload
        self.ptr = ptr
        self.wire = payload + ptr
        self.signature = Packet.hash_algo(self.wire).digest()[:20]


class Packet:
    &#34;&#34;&#34;
    Contains all the information as defined in tiny-ssb protocol.
    Contains bytes payload and feed information.
    The hashing and signing algorithms can be changed thorugh the
    &#39;hash_algo&#39; and &#39;sign_algo&#39; fields.
    The maximum payload size of a packet is 48B.
    &#34;&#34;&#34;

    prefix = b&#34;tiny-v01&#34;  # len must be 8B
    hash_algo = hashlib.sha256
    sign_algo = sign
    secret = b&#34;bad secret&#34;

    def __init__(self, fid: bytes, seq: bytes,
                 prev_mid: bytes, payload: bytes = bytes(48),
                 pkt_type: int = PacketType.plain48):

        assert len(fid) == 32, &#34;fid must be 32B&#34;
        assert len(seq) == 4, &#34;sequence number must be 4B&#34;
        assert len(prev_mid) == 20, &#34;previous msg_id must be 20B&#34;
        # make sure that payload is 48 bytes, rejected if too long
        if payload is None:
            payload = bytes(48)
        if len(payload) &lt; 48:
            # too short -&gt; append 0s
            missing = 48 - len(payload)
            payload += bytes(missing)
        assert len(payload) == 48, &#34;payload must be 48B&#34;

        self.log_entry_name = self.prefix + fid + seq + prev_mid
        self.fid = fid
        self.seq = seq
        self.prev_mid = prev_mid
        self.payload = payload
        self.pkt_type = pkt_type
        self.dmx = self._calc_dmx()
        self.signature = self._calc_signature()
        self.mid = self._calc_mid()
        self.wire = self._get_wire()

    def __repr__(self):
        s = &#34;packet(\nfeed_id:{},\nseq:{},\n&#34;.format(self.fid,
                                                     self.seq)
        s += &#34;prev_mid:{},\npayload:{},\ndmx:{}\n&#34;.format(self.prev_mid,
                                                          self.payload,
                                                          self.dmx)
        s += &#34;sig:{},\nmid:{},\nwire:{})&#34;.format(self.signature,
                                                 self.mid,
                                                 self.wire)
        return s

    def _calc_dmx(self) -&gt; bytes:
        &#34;&#34;&#34;
        Calculates the demultiplexing field of the packet.
        &#34;&#34;&#34;
        hash_algo = self.hash_algo()
        hash_algo.update(self.log_entry_name)
        return hash_algo.digest()[:7]

    def next_dmx(self) -&gt; bytes:
        &#34;&#34;&#34;
        Predicts the next packet&#39;s dmx value.
        &#34;&#34;&#34;
        next = self.fid + (self.seq + 1).to_bytes(4, &#34;big&#34;) + self.mid
        return self.hash_algo(next).digest()[:20]

    def _expand(self) -&gt; bytes:
        &#34;&#34;&#34;
        Computes the 128B expanded log entry containing &#39;virtual&#39; information.
        &#34;&#34;&#34;
        return self.log_entry_name + self.dmx + self.pkt_type + self.payload

    def _calc_signature(self) -&gt; bytes:
        &#34;&#34;&#34;
        Computes the signature of the packet.
        For now, sha256 HMAC using symmetric key is used.
        Can be swapped out through &#39;sign_algo&#39; field.
        &#34;&#34;&#34;
        return self.sign_algo(self.secret, self._expand())

    def _get_full(self) -&gt; bytes:
        &#34;&#34;&#34;
        Computes the full 184B log entry.
        Consists of the expanded log entry and
        the signature of the packet.
        &#34;&#34;&#34;
        return self._expand() + self._calc_signature()

    def _calc_mid(self) -&gt; bytes:
        &#34;&#34;&#34;
        Computes the 20B message ID of the packet.
        This message ID is referenced in the next packet.
        &#34;&#34;&#34;
        hash_algo = self.hash_algo()
        hash_algo.update(self._get_full())
        return hash_algo.digest()[:20]

    def _get_wire(self) -&gt; bytes:
        &#34;&#34;&#34;
        Returns the 120B &#39;raw&#39; wire format of the packet.
        The missing &#39;virtual&#39; information can be infereed by
        the recipient using prior packets.
        &#34;&#34;&#34;
        return self.dmx + self.pkt_type + self.payload + self.signature


def pkt_from_bytes(fid: bytes, seq: bytes,
                   prev_mid: bytes, raw_pkt: bytes) -&gt; Packet:
    &#34;&#34;&#34;
    Creates a Packet instance from the given feed ID, sequence number
    previous message ID and wire bytes.
    Also validates the packet.
    If the signatures do not match, &#39;None&#39; is returned.
    &#34;&#34;&#34;
    assert len(raw_pkt) == 120, &#34;raw packet length must be 120B&#34;
    # dmx = raw_pkt[:7]
    pkt_type = raw_pkt[7:8]
    payload = raw_pkt[8:56]
    signature = raw_pkt[56:]

    pkt = Packet(fid, seq, prev_mid, payload, pkt_type=pkt_type)

    # confirm packet
    if signature != pkt.signature:
        print(&#34;packet not trusted&#34;)
        return None
    return pkt


def create_genesis_pkt(fid: bytes, payload: bytes) -&gt; Packet:
    &#34;&#34;&#34;
    Creates and returns a &#39;self-signed&#39; Packet instance
    with sequence number of 1.
    Also contains a payload of max 48B.
    Used when creating new logs.
    &#34;&#34;&#34;
    seq = (1).to_bytes(4, &#34;big&#34;)  # seq numbers start at 1
    prev_mid = fid[:20]  # tiny ssb convention
    return Packet(fid, seq, prev_mid, payload)


def create_parent_pkt(fid: bytes, seq: bytes,
                      prev_mid: bytes, child_fid: bytes) -&gt; Packet:
    &#34;&#34;&#34;
    Creates and returns a packet instance of type &#39;mkchild&#39;.
    Is used in parent log, to refer to child logs.
    No payload can be attached to this packet,
    as it contains information about the child feed.
    &#34;&#34;&#34;
    # TODO: maybe add time stamp?
    return Packet(fid, seq, prev_mid,
                  payload=child_fid, pkt_type=PacketType.mkchild)


def create_child_pkt(fid: bytes, payload: bytes) -&gt; Packet:
    &#34;&#34;&#34;
    Creates and returns the first packet of a new child feed.
    Starts with sequence number 1 and has
    packet type &#39;ischild&#39;.
    &#34;&#34;&#34;
    seq = (1).to_bytes(4, &#34;big&#34;)
    prev_mid = fid[:20]
    return Packet(fid, seq, prev_mid,
                  payload, pkt_type=PacketType.ischild)


def create_end_pkt(fid: bytes, seq: bytes,
                   prev_mid: bytes, contn_fid: bytes) -&gt; Packet:
    &#34;&#34;&#34;
    Creates and returns the last packet of a feed.
    Contains information of the continuing feed.
    Has packet type &#39;contdas&#39;.
    &#34;&#34;&#34;
    # TODO: maybe add time stamp?
    return Packet(fid, seq, prev_mid,
                  payload=contn_fid, pkt_type=PacketType.contdas)


def create_contn_pkt(fid: bytes, payload: bytes) -&gt; Packet:
    &#34;&#34;&#34;
    Creates and returns the first packet of a continuation feed.
    Starts at sequence number 1 and has packet type &#39;iscontn&#39;.
    &#34;&#34;&#34;
    seq = (1).to_bytes(4, &#34;big&#34;)
    prev_mid = fid[:20]
    return Packet(fid, seq, prev_mid,
                  payload, pkt_type=PacketType.iscontn)


def create_succ(prev: Packet, payload: bytes) -&gt; Packet:
    &#34;&#34;&#34;
    Creates and returns the successor of the given packet,
    containing the given payload.
    &#34;&#34;&#34;
    seq = int.from_bytes(prev.seq, &#34;big&#34;) + 1
    return Packet(prev.fid, (seq).to_bytes(4, &#34;big&#34;), prev.mid, payload)


def create_chain(fid: bytes, seq: bytes, prev_mid: bytes,
                 content: bytes) -&gt; (Packet, [Blob]):
    &#34;&#34;&#34;
    Creates a blob chain, containing the given bytes (content).
    The blob is returned as a tuple, containing the header of the blob
    as a packet and a list containing Blob instances.
    Blob instances can easily be saved as bytes by using blob.wire.
    The blob list is empty if the content fits into the blob header.
    &#34;&#34;&#34;
    chain = []
    # get size as VarInt and prepend to content
    size = to_var_int(len(content))
    content = size + content

    # check if content fits into single blob
    num_fill = 28 - len(content)  # how many bytes left to fill content
    if num_fill &gt;= 0:
        # only one blob -&gt; null pointer at end
        payload = content + bytes(num_fill)
        header = payload
        ptr = bytes(20)
    else:
        # pad msg -&gt; divisible by 100
        header = content[:28]
        content = content[28:]
        pad = 100 - len(content) % 100
        content += bytes(pad)
        # start with last pkt
        ptr = bytes(20)
        while len(content) != 0:
            blob = Blob(content[-100:], ptr)
            chain.append(blob)
            # get next pointer
            ptr = blob.signature
            # cut content
            content = content[:-100]

    # create first pkt
    payload = header + ptr
    assert len(payload) == 48, &#34;blob header must be 48B&#34;
    pkt = Packet(fid, seq, prev_mid,
                 payload, pkt_type=PacketType.chain20)

    chain.reverse()
    return (pkt, chain)


def dmx(name: bytes) -&gt; bytes:
    &#34;&#34;&#34;
    Calculates and returns the dmx value for the given name.
    &#34;&#34;&#34;
    log_entry_name = Packet.prefix + name
    hash_algo = Packet.hash_algo()
    hash_algo.update(log_entry_name)
    return hash_algo.digest()[:7]</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="packet.create_chain"><code class="name flex">
<span>def <span class="ident">create_chain</span></span>(<span>fid: bytes, seq: bytes, prev_mid: bytes, content: bytes) ‑> (<class '<a title="packet.Packet" href="#packet.Packet">Packet</a>'>, [<class '<a title="packet.Blob" href="#packet.Blob">Blob</a>'>])</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a blob chain, containing the given bytes (content).
The blob is returned as a tuple, containing the header of the blob
as a packet and a list containing Blob instances.
Blob instances can easily be saved as bytes by using blob.wire.
The blob list is empty if the content fits into the blob header.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_chain(fid: bytes, seq: bytes, prev_mid: bytes,
                 content: bytes) -&gt; (Packet, [Blob]):
    &#34;&#34;&#34;
    Creates a blob chain, containing the given bytes (content).
    The blob is returned as a tuple, containing the header of the blob
    as a packet and a list containing Blob instances.
    Blob instances can easily be saved as bytes by using blob.wire.
    The blob list is empty if the content fits into the blob header.
    &#34;&#34;&#34;
    chain = []
    # get size as VarInt and prepend to content
    size = to_var_int(len(content))
    content = size + content

    # check if content fits into single blob
    num_fill = 28 - len(content)  # how many bytes left to fill content
    if num_fill &gt;= 0:
        # only one blob -&gt; null pointer at end
        payload = content + bytes(num_fill)
        header = payload
        ptr = bytes(20)
    else:
        # pad msg -&gt; divisible by 100
        header = content[:28]
        content = content[28:]
        pad = 100 - len(content) % 100
        content += bytes(pad)
        # start with last pkt
        ptr = bytes(20)
        while len(content) != 0:
            blob = Blob(content[-100:], ptr)
            chain.append(blob)
            # get next pointer
            ptr = blob.signature
            # cut content
            content = content[:-100]

    # create first pkt
    payload = header + ptr
    assert len(payload) == 48, &#34;blob header must be 48B&#34;
    pkt = Packet(fid, seq, prev_mid,
                 payload, pkt_type=PacketType.chain20)

    chain.reverse()
    return (pkt, chain)</code></pre>
</details>
</dd>
<dt id="packet.create_child_pkt"><code class="name flex">
<span>def <span class="ident">create_child_pkt</span></span>(<span>fid: bytes, payload: bytes) ‑> <a title="packet.Packet" href="#packet.Packet">Packet</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates and returns the first packet of a new child feed.
Starts with sequence number 1 and has
packet type 'ischild'.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_child_pkt(fid: bytes, payload: bytes) -&gt; Packet:
    &#34;&#34;&#34;
    Creates and returns the first packet of a new child feed.
    Starts with sequence number 1 and has
    packet type &#39;ischild&#39;.
    &#34;&#34;&#34;
    seq = (1).to_bytes(4, &#34;big&#34;)
    prev_mid = fid[:20]
    return Packet(fid, seq, prev_mid,
                  payload, pkt_type=PacketType.ischild)</code></pre>
</details>
</dd>
<dt id="packet.create_contn_pkt"><code class="name flex">
<span>def <span class="ident">create_contn_pkt</span></span>(<span>fid: bytes, payload: bytes) ‑> <a title="packet.Packet" href="#packet.Packet">Packet</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates and returns the first packet of a continuation feed.
Starts at sequence number 1 and has packet type 'iscontn'.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_contn_pkt(fid: bytes, payload: bytes) -&gt; Packet:
    &#34;&#34;&#34;
    Creates and returns the first packet of a continuation feed.
    Starts at sequence number 1 and has packet type &#39;iscontn&#39;.
    &#34;&#34;&#34;
    seq = (1).to_bytes(4, &#34;big&#34;)
    prev_mid = fid[:20]
    return Packet(fid, seq, prev_mid,
                  payload, pkt_type=PacketType.iscontn)</code></pre>
</details>
</dd>
<dt id="packet.create_end_pkt"><code class="name flex">
<span>def <span class="ident">create_end_pkt</span></span>(<span>fid: bytes, seq: bytes, prev_mid: bytes, contn_fid: bytes) ‑> <a title="packet.Packet" href="#packet.Packet">Packet</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates and returns the last packet of a feed.
Contains information of the continuing feed.
Has packet type 'contdas'.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_end_pkt(fid: bytes, seq: bytes,
                   prev_mid: bytes, contn_fid: bytes) -&gt; Packet:
    &#34;&#34;&#34;
    Creates and returns the last packet of a feed.
    Contains information of the continuing feed.
    Has packet type &#39;contdas&#39;.
    &#34;&#34;&#34;
    # TODO: maybe add time stamp?
    return Packet(fid, seq, prev_mid,
                  payload=contn_fid, pkt_type=PacketType.contdas)</code></pre>
</details>
</dd>
<dt id="packet.create_genesis_pkt"><code class="name flex">
<span>def <span class="ident">create_genesis_pkt</span></span>(<span>fid: bytes, payload: bytes) ‑> <a title="packet.Packet" href="#packet.Packet">Packet</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates and returns a 'self-signed' Packet instance
with sequence number of 1.
Also contains a payload of max 48B.
Used when creating new logs.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_genesis_pkt(fid: bytes, payload: bytes) -&gt; Packet:
    &#34;&#34;&#34;
    Creates and returns a &#39;self-signed&#39; Packet instance
    with sequence number of 1.
    Also contains a payload of max 48B.
    Used when creating new logs.
    &#34;&#34;&#34;
    seq = (1).to_bytes(4, &#34;big&#34;)  # seq numbers start at 1
    prev_mid = fid[:20]  # tiny ssb convention
    return Packet(fid, seq, prev_mid, payload)</code></pre>
</details>
</dd>
<dt id="packet.create_parent_pkt"><code class="name flex">
<span>def <span class="ident">create_parent_pkt</span></span>(<span>fid: bytes, seq: bytes, prev_mid: bytes, child_fid: bytes) ‑> <a title="packet.Packet" href="#packet.Packet">Packet</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates and returns a packet instance of type 'mkchild'.
Is used in parent log, to refer to child logs.
No payload can be attached to this packet,
as it contains information about the child feed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_parent_pkt(fid: bytes, seq: bytes,
                      prev_mid: bytes, child_fid: bytes) -&gt; Packet:
    &#34;&#34;&#34;
    Creates and returns a packet instance of type &#39;mkchild&#39;.
    Is used in parent log, to refer to child logs.
    No payload can be attached to this packet,
    as it contains information about the child feed.
    &#34;&#34;&#34;
    # TODO: maybe add time stamp?
    return Packet(fid, seq, prev_mid,
                  payload=child_fid, pkt_type=PacketType.mkchild)</code></pre>
</details>
</dd>
<dt id="packet.create_succ"><code class="name flex">
<span>def <span class="ident">create_succ</span></span>(<span>prev: <a title="packet.Packet" href="#packet.Packet">Packet</a>, payload: bytes) ‑> <a title="packet.Packet" href="#packet.Packet">Packet</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates and returns the successor of the given packet,
containing the given payload.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_succ(prev: Packet, payload: bytes) -&gt; Packet:
    &#34;&#34;&#34;
    Creates and returns the successor of the given packet,
    containing the given payload.
    &#34;&#34;&#34;
    seq = int.from_bytes(prev.seq, &#34;big&#34;) + 1
    return Packet(prev.fid, (seq).to_bytes(4, &#34;big&#34;), prev.mid, payload)</code></pre>
</details>
</dd>
<dt id="packet.dmx"><code class="name flex">
<span>def <span class="ident">dmx</span></span>(<span>name: bytes) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates and returns the dmx value for the given name.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dmx(name: bytes) -&gt; bytes:
    &#34;&#34;&#34;
    Calculates and returns the dmx value for the given name.
    &#34;&#34;&#34;
    log_entry_name = Packet.prefix + name
    hash_algo = Packet.hash_algo()
    hash_algo.update(log_entry_name)
    return hash_algo.digest()[:7]</code></pre>
</details>
</dd>
<dt id="packet.pkt_from_bytes"><code class="name flex">
<span>def <span class="ident">pkt_from_bytes</span></span>(<span>fid: bytes, seq: bytes, prev_mid: bytes, raw_pkt: bytes) ‑> <a title="packet.Packet" href="#packet.Packet">Packet</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates a Packet instance from the given feed ID, sequence number
previous message ID and wire bytes.
Also validates the packet.
If the signatures do not match, 'None' is returned.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pkt_from_bytes(fid: bytes, seq: bytes,
                   prev_mid: bytes, raw_pkt: bytes) -&gt; Packet:
    &#34;&#34;&#34;
    Creates a Packet instance from the given feed ID, sequence number
    previous message ID and wire bytes.
    Also validates the packet.
    If the signatures do not match, &#39;None&#39; is returned.
    &#34;&#34;&#34;
    assert len(raw_pkt) == 120, &#34;raw packet length must be 120B&#34;
    # dmx = raw_pkt[:7]
    pkt_type = raw_pkt[7:8]
    payload = raw_pkt[8:56]
    signature = raw_pkt[56:]

    pkt = Packet(fid, seq, prev_mid, payload, pkt_type=pkt_type)

    # confirm packet
    if signature != pkt.signature:
        print(&#34;packet not trusted&#34;)
        return None
    return pkt</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="packet.Blob"><code class="flex name class">
<span>class <span class="ident">Blob</span></span>
<span>(</span><span>payload: bytes, ptr: bytes)</span>
</code></dt>
<dd>
<div class="desc"><p>Simple class for handeling blob information.
Not used for first blob entry (Packet).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Blob:
    &#34;&#34;&#34;
    Simple class for handeling blob information.
    Not used for first blob entry (Packet).
    &#34;&#34;&#34;

    def __init__(self, payload: bytes, ptr: bytes):
        self.payload = payload
        self.ptr = ptr
        self.wire = payload + ptr
        self.signature = Packet.hash_algo(self.wire).digest()[:20]</code></pre>
</details>
</dd>
<dt id="packet.Packet"><code class="flex name class">
<span>class <span class="ident">Packet</span></span>
<span>(</span><span>fid: bytes, seq: bytes, prev_mid: bytes, payload: bytes = b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00', pkt_type: int = b'\x00')</span>
</code></dt>
<dd>
<div class="desc"><p>Contains all the information as defined in tiny-ssb protocol.
Contains bytes payload and feed information.
The hashing and signing algorithms can be changed thorugh the
'hash_algo' and 'sign_algo' fields.
The maximum payload size of a packet is 48B.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Packet:
    &#34;&#34;&#34;
    Contains all the information as defined in tiny-ssb protocol.
    Contains bytes payload and feed information.
    The hashing and signing algorithms can be changed thorugh the
    &#39;hash_algo&#39; and &#39;sign_algo&#39; fields.
    The maximum payload size of a packet is 48B.
    &#34;&#34;&#34;

    prefix = b&#34;tiny-v01&#34;  # len must be 8B
    hash_algo = hashlib.sha256
    sign_algo = sign
    secret = b&#34;bad secret&#34;

    def __init__(self, fid: bytes, seq: bytes,
                 prev_mid: bytes, payload: bytes = bytes(48),
                 pkt_type: int = PacketType.plain48):

        assert len(fid) == 32, &#34;fid must be 32B&#34;
        assert len(seq) == 4, &#34;sequence number must be 4B&#34;
        assert len(prev_mid) == 20, &#34;previous msg_id must be 20B&#34;
        # make sure that payload is 48 bytes, rejected if too long
        if payload is None:
            payload = bytes(48)
        if len(payload) &lt; 48:
            # too short -&gt; append 0s
            missing = 48 - len(payload)
            payload += bytes(missing)
        assert len(payload) == 48, &#34;payload must be 48B&#34;

        self.log_entry_name = self.prefix + fid + seq + prev_mid
        self.fid = fid
        self.seq = seq
        self.prev_mid = prev_mid
        self.payload = payload
        self.pkt_type = pkt_type
        self.dmx = self._calc_dmx()
        self.signature = self._calc_signature()
        self.mid = self._calc_mid()
        self.wire = self._get_wire()

    def __repr__(self):
        s = &#34;packet(\nfeed_id:{},\nseq:{},\n&#34;.format(self.fid,
                                                     self.seq)
        s += &#34;prev_mid:{},\npayload:{},\ndmx:{}\n&#34;.format(self.prev_mid,
                                                          self.payload,
                                                          self.dmx)
        s += &#34;sig:{},\nmid:{},\nwire:{})&#34;.format(self.signature,
                                                 self.mid,
                                                 self.wire)
        return s

    def _calc_dmx(self) -&gt; bytes:
        &#34;&#34;&#34;
        Calculates the demultiplexing field of the packet.
        &#34;&#34;&#34;
        hash_algo = self.hash_algo()
        hash_algo.update(self.log_entry_name)
        return hash_algo.digest()[:7]

    def next_dmx(self) -&gt; bytes:
        &#34;&#34;&#34;
        Predicts the next packet&#39;s dmx value.
        &#34;&#34;&#34;
        next = self.fid + (self.seq + 1).to_bytes(4, &#34;big&#34;) + self.mid
        return self.hash_algo(next).digest()[:20]

    def _expand(self) -&gt; bytes:
        &#34;&#34;&#34;
        Computes the 128B expanded log entry containing &#39;virtual&#39; information.
        &#34;&#34;&#34;
        return self.log_entry_name + self.dmx + self.pkt_type + self.payload

    def _calc_signature(self) -&gt; bytes:
        &#34;&#34;&#34;
        Computes the signature of the packet.
        For now, sha256 HMAC using symmetric key is used.
        Can be swapped out through &#39;sign_algo&#39; field.
        &#34;&#34;&#34;
        return self.sign_algo(self.secret, self._expand())

    def _get_full(self) -&gt; bytes:
        &#34;&#34;&#34;
        Computes the full 184B log entry.
        Consists of the expanded log entry and
        the signature of the packet.
        &#34;&#34;&#34;
        return self._expand() + self._calc_signature()

    def _calc_mid(self) -&gt; bytes:
        &#34;&#34;&#34;
        Computes the 20B message ID of the packet.
        This message ID is referenced in the next packet.
        &#34;&#34;&#34;
        hash_algo = self.hash_algo()
        hash_algo.update(self._get_full())
        return hash_algo.digest()[:20]

    def _get_wire(self) -&gt; bytes:
        &#34;&#34;&#34;
        Returns the 120B &#39;raw&#39; wire format of the packet.
        The missing &#39;virtual&#39; information can be infereed by
        the recipient using prior packets.
        &#34;&#34;&#34;
        return self.dmx + self.pkt_type + self.payload + self.signature</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="packet.Packet.prefix"><code class="name">var <span class="ident">prefix</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="packet.Packet.secret"><code class="name">var <span class="ident">secret</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="packet.Packet.hash_algo"><code class="name flex">
<span>def <span class="ident">hash_algo</span></span>(<span>string=b'', *, usedforsecurity=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a sha256 hash object; optionally initialized with a string</p></div>
</dd>
<dt id="packet.Packet.next_dmx"><code class="name flex">
<span>def <span class="ident">next_dmx</span></span>(<span>self) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Predicts the next packet's dmx value.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def next_dmx(self) -&gt; bytes:
    &#34;&#34;&#34;
    Predicts the next packet&#39;s dmx value.
    &#34;&#34;&#34;
    next = self.fid + (self.seq + 1).to_bytes(4, &#34;big&#34;) + self.mid
    return self.hash_algo(next).digest()[:20]</code></pre>
</details>
</dd>
<dt id="packet.Packet.sign_algo"><code class="name flex">
<span>def <span class="ident">sign_algo</span></span>(<span>pkt_instance, key: bytes, payload: bytes) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates the HMAC signature of the given bytes.
Uses the given symmetric key.
The signature is padded to 64B for tiny ssb compatibility.
Must be called from within a class (e.g. Packet).
The first argument is the caller class instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sign(pkt_instance, key: bytes, payload: bytes) -&gt; bytes:
    &#34;&#34;&#34;
    Calculates the HMAC signature of the given bytes.
    Uses the given symmetric key.
    The signature is padded to 64B for tiny ssb compatibility.
    Must be called from within a class (e.g. Packet).
    The first argument is the caller class instance.
    &#34;&#34;&#34;
    hmac = HMAC(key)
    return hmac.get_signature(payload) + bytes(32)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="packet.PacketType"><code class="flex name class">
<span>class <span class="ident">PacketType</span></span>
</code></dt>
<dd>
<div class="desc"><p>Enum containing different packet types
(as defined in tiny-ssb protocol).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PacketType:
    &#34;&#34;&#34;
    Enum containing different packet types
    (as defined in tiny-ssb protocol).
    &#34;&#34;&#34;

    plain48 = bytes([0x00])  # sha256 HMAC signature, signle packet with 48B
    chain20 = bytes([0x01])  # sha256 HMAC signature, start of hash sidechain
    ischild = bytes([0x02])  # metafeed information, only in genesis block
    iscontn = bytes([0x03])  # metafeed information, only in genesis block
    mkchild = bytes([0x04])  # metafeed information
    contdas = bytes([0x05])  # metafeed information</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="packet.PacketType.chain20"><code class="name">var <span class="ident">chain20</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="packet.PacketType.contdas"><code class="name">var <span class="ident">contdas</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="packet.PacketType.ischild"><code class="name">var <span class="ident">ischild</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="packet.PacketType.iscontn"><code class="name">var <span class="ident">iscontn</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="packet.PacketType.mkchild"><code class="name">var <span class="ident">mkchild</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="packet.PacketType.plain48"><code class="name">var <span class="ident">plain48</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="packet.create_chain" href="#packet.create_chain">create_chain</a></code></li>
<li><code><a title="packet.create_child_pkt" href="#packet.create_child_pkt">create_child_pkt</a></code></li>
<li><code><a title="packet.create_contn_pkt" href="#packet.create_contn_pkt">create_contn_pkt</a></code></li>
<li><code><a title="packet.create_end_pkt" href="#packet.create_end_pkt">create_end_pkt</a></code></li>
<li><code><a title="packet.create_genesis_pkt" href="#packet.create_genesis_pkt">create_genesis_pkt</a></code></li>
<li><code><a title="packet.create_parent_pkt" href="#packet.create_parent_pkt">create_parent_pkt</a></code></li>
<li><code><a title="packet.create_succ" href="#packet.create_succ">create_succ</a></code></li>
<li><code><a title="packet.dmx" href="#packet.dmx">dmx</a></code></li>
<li><code><a title="packet.pkt_from_bytes" href="#packet.pkt_from_bytes">pkt_from_bytes</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="packet.Blob" href="#packet.Blob">Blob</a></code></h4>
</li>
<li>
<h4><code><a title="packet.Packet" href="#packet.Packet">Packet</a></code></h4>
<ul class="">
<li><code><a title="packet.Packet.hash_algo" href="#packet.Packet.hash_algo">hash_algo</a></code></li>
<li><code><a title="packet.Packet.next_dmx" href="#packet.Packet.next_dmx">next_dmx</a></code></li>
<li><code><a title="packet.Packet.prefix" href="#packet.Packet.prefix">prefix</a></code></li>
<li><code><a title="packet.Packet.secret" href="#packet.Packet.secret">secret</a></code></li>
<li><code><a title="packet.Packet.sign_algo" href="#packet.Packet.sign_algo">sign_algo</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="packet.PacketType" href="#packet.PacketType">PacketType</a></code></h4>
<ul class="two-column">
<li><code><a title="packet.PacketType.chain20" href="#packet.PacketType.chain20">chain20</a></code></li>
<li><code><a title="packet.PacketType.contdas" href="#packet.PacketType.contdas">contdas</a></code></li>
<li><code><a title="packet.PacketType.ischild" href="#packet.PacketType.ischild">ischild</a></code></li>
<li><code><a title="packet.PacketType.iscontn" href="#packet.PacketType.iscontn">iscontn</a></code></li>
<li><code><a title="packet.PacketType.mkchild" href="#packet.PacketType.mkchild">mkchild</a></code></li>
<li><code><a title="packet.PacketType.plain48" href="#packet.PacketType.plain48">plain48</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>