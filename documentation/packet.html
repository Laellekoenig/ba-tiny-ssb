<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>tinyssb.packet API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>tinyssb.packet</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import hashlib
import sys
from .crypto import sign_elliptic
from .crypto import verify_elliptic
from .ssb_util import to_var_int

# non-micropython import
if sys.implementation.name != &#34;micropython&#34;:
    # Optional type annotations are ignored in micropython
    from typing import Optional
    from typing import List
    from typing import Tuple


class PacketType:
    &#34;&#34;&#34;
    Enum containing different packet types
    (as defined in tiny-ssb protocol).
    &#34;&#34;&#34;
    plain48 = bytes([0x00])  # sha256 HMAC signature, signle packet with 48B
    chain20 = bytes([0x01])  # sha256 HMAC signature, start of hash sidechain
    ischild = bytes([0x02])  # metafeed information, only in genesis block
    iscontn = bytes([0x03])  # metafeed information, only in genesis block
    mkchild = bytes([0x04])  # metafeed information
    contdas = bytes([0x05])  # metafeed information
    types = [plain48, chain20, ischild, iscontn, mkchild, contdas]

    @classmethod
    def is_type(cls, t: bytes) -&gt; bool:
        &#34;&#34;&#34;
        Returns True if there exists a packet type with the same
        number as the given int.
        &#34;&#34;&#34;
        return t in cls.types


class Blob:
    &#34;&#34;&#34;
    Simple class for handling blob information.
    Not used for first blob entry (Packet).
    Uses sha256 for generating pointers to next blob.
    &#34;&#34;&#34;
    def __init__(self, payload: bytes, ptr: bytes):
        self.payload = payload
        self.ptr = ptr
        self.wire = payload + ptr
        self.signature = hashlib.sha256(self.wire).digest()[:20]


class Packet:
    &#34;&#34;&#34;
    As defined in the tiny sbb protocol.
    Contains physical and virtual information.
    The maximum payload size of a packet is 48B.
    Uses ed25519 for signing and verifying Packets.
    &#34;&#34;&#34;
    prefix = b&#34;tiny-v01&#34;  # length must be 8B

    def __init__(self,
                 fid: bytes,
                 seq: bytes,
                 prev_mid: bytes,
                 payload: bytes = bytes(48),
                 pkt_type: bytes = PacketType.plain48,  # default
                 skey: Optional[bytes] = None):

        # check arguments
        assert len(fid) == 32, &#34;feed ID must be 32B&#34;
        assert len(seq) == 4, &#34;sequence number must be 4B&#34;
        assert len(prev_mid) == 20, &#34;previous msg_id must be 20B&#34;
        assert (skey is None or
                len(skey) == 32), &#34;skey must be 32B or None&#34;

        # make sure that payload is 48 bytes, rejected if too long
        if len(payload) &lt; 48:
            # too short -&gt; append 0s
            missing = 48 - len(payload)
            payload += bytes(missing)
        assert len(payload) == 48, &#34;payload must be 48B&#34;

        # build packet
        self.block_name = self.prefix + fid + seq + prev_mid
        self.fid = fid
        self.seq = seq
        self.prev_mid = prev_mid
        self.payload = payload
        self.pkt_type = pkt_type
        self.skey = skey
        self.dmx = self._calc_dmx()

        # sign, if possible
        if self.skey is None:
            self.signature = None
            self.mid = None
            self.wire = None
        else:
            self.signature = self._calc_signature()
            self.mid = self._calc_mid()
            self.wire = self._get_wire()

    def __repr__(self):
        s = &#34;Packet\n&#34;
        s += &#34;------\n&#34;
        s += &#34;fid:\t{}\n&#34;.format(self.fid)
        s += &#34;seq:\t{}\n&#34;.format(self.seq)
        s += &#34;prev_mid:\t{}\n&#34;.format(self.prev_mid)
        s += &#34;payload:\t{}\n&#34;.format(self.payload)
        s += &#34;type:\t{}\n&#34;.format(self.pkt_type)
        s += &#34;mid:\t{}\n&#34;.format(self.mid)
        s += &#34;signature:\t{}&#34;.format(self.signature)
        return s

    def _calc_dmx(self) -&gt; bytes:
        &#34;&#34;&#34;
        Calculates the demultiplexing field of the packet.
        &#34;&#34;&#34;
        return hashlib.sha256(self.block_name).digest()[:7]

    def next_dmx(self) -&gt; bytes:
        &#34;&#34;&#34;
        Predicts the next packet&#39;s dmx value.
        &#34;&#34;&#34;
        assert self.mid is not None, &#34;sign packet first&#34;

        next_seq = int.from_bytes(self.seq, &#34;big&#34;) + 1
        next = self.prefix + self.fid + next_seq.to_bytes(4, &#34;big&#34;) + self.mid
        return hashlib.sha256(next).digest()[:20]

    def _expand(self) -&gt; bytes:
        &#34;&#34;&#34;
        Computes the 128B expanded block containing &#39;virtual&#39; information.
        &#34;&#34;&#34;
        return self.block_name + self.dmx + self.pkt_type + self.payload

    def _calc_signature(self) -&gt; bytes:
        &#34;&#34;&#34;
        Computes the signature of the packet using the ed25519 algorithm..
        &#34;&#34;&#34;
        assert self.skey is not None, &#34;key needed for signing&#34;
        return sign_elliptic(self.skey, self._expand())

    def _get_full(self) -&gt; bytes:
        &#34;&#34;&#34;
        Computes the full 184B block.
        Consists of the expanded block and
        the signature of the packet.
        &#34;&#34;&#34;
        if self.signature is not None:
            # signature already calculated
            return self._expand() + self.signature
        return self._expand() + self._calc_signature()

    def _calc_mid(self) -&gt; bytes:
        &#34;&#34;&#34;
        Computes the 20B message ID of the packet.
        This message ID is referenced in the next packet.
        &#34;&#34;&#34;
        return hashlib.sha256(self._get_full()).digest()[:20]

    def _get_wire(self) -&gt; bytes:
        &#34;&#34;&#34;
        Returns the 120B &#39;raw&#39; wire format of the packet.
        The missing &#39;virtual&#39; information can be inferred by
        the recipient using prior packets.
        &#34;&#34;&#34;
        assert self.signature is not None, &#34;sign packet first&#34;
        return self.dmx + self.pkt_type + self.payload + self.signature

    def sign(self, skey: bytes = bytes(32)) -&gt; None:
        &#34;&#34;&#34;Calculates the signature of the Packet and all the related fields
        using the given signing key.
        For testing, the default key is 32 0s.&#34;&#34;&#34;
        assert len(skey) == 32, &#34;skey must be 32B&#34;
        self.skey = skey
        self.signature = self._calc_signature()
        self.mid = self._calc_mid()
        self.wire = self._get_wire()


def pkt_from_bytes(fid: bytes,
                   seq: bytes,
                   prev_mid: bytes,
                   pkt_wire: bytes) -&gt; Optional[Packet]:
    &#34;&#34;&#34;
    Creates a Packet instance from the given feed ID, sequence number
    previous message ID and wire bytes.
    Also validates the packet.
    If the signatures do not match, &#39;None&#39; is returned.
    &#34;&#34;&#34;
    assert len(pkt_wire) == 120, &#34;length of packet wire format must be 120B&#34;
    assert len(fid) == 32, &#34;feed id must be 32B&#34;

    # dmx = raw_pkt[:7]
    pkt_type = pkt_wire[7:8]
    payload = pkt_wire[8:56]
    signature = pkt_wire[56:]

    # create unsigned Packet
    pkt = Packet(fid, seq, prev_mid, payload, pkt_type=pkt_type)

    # use fid as verification key
    if verify_elliptic(pkt._expand(), signature, fid):
        # verification successful
        # fill-in signature and calculate missing info
        pkt.signature = signature
        pkt.mid = pkt._calc_mid()
        pkt.wire = pkt_wire
        return pkt
    else:
        print(&#34;packet not trusted&#34;)
        return None


def create_genesis_pkt(fid: bytes, payload: bytes, skey: bytes) -&gt; Packet:
    &#34;&#34;&#34;
    Creates and returns a &#39;self-signed&#39; Packet instance
    with sequence number 1.
    Also contains a payload of max. 48B.
    Used when creating new feeds.
    &#34;&#34;&#34;
    seq = (1).to_bytes(4, &#34;big&#34;)  # seq numbers start at 1
    prev_mid = fid[:20]  # tiny ssb convention
    return Packet(fid, seq, prev_mid, payload, skey=skey)


def create_parent_pkt(fid: bytes,
                      seq: bytes,
                      prev_mid: bytes,
                      child_fid: bytes,
                      skey: bytes) -&gt; Packet:
    &#34;&#34;&#34;
    Creates and returns a Packet instance of type &#39;mkchild&#39;.
    Is used in parent feed, to refer to child feed.
    No payload can be attached to this packet,
    as it contains information about the child feed.
    &#34;&#34;&#34;
    # TODO: add more info (time stamp?)
    return Packet(fid, seq, prev_mid, payload=child_fid,
                  pkt_type=PacketType.mkchild, skey=skey)


def create_child_pkt(fid: bytes, payload: bytes, skey: bytes) -&gt; Packet:
    &#34;&#34;&#34;
    Creates and returns the first packet of a new child feed.
    Starts with sequence number 1 and has packet type &#39;ischild&#39;.
    &#34;&#34;&#34;
    seq = (1).to_bytes(4, &#34;big&#34;)
    prev_mid = fid[:20]
    return Packet(fid, seq, prev_mid, payload,
                  pkt_type=PacketType.ischild, skey=skey)


def create_end_pkt(fid: bytes,
                   seq: bytes,
                   prev_mid: bytes,
                   contn_fid: bytes,
                   skey: bytes) -&gt; Packet:
    &#34;&#34;&#34;
    Creates and returns the last packet of a feed.
    Contains information of the continuing feed.
    Has packet type &#39;contdas&#39;.
    &#34;&#34;&#34;
    # TODO: add more info (time stamp?)
    return Packet(fid, seq, prev_mid, payload=contn_fid,
                  pkt_type=PacketType.contdas, skey=skey)


def create_contn_pkt(fid: bytes, payload: bytes, skey: bytes) -&gt; Packet:
    &#34;&#34;&#34;
    Creates and returns the first packet of a continuation feed.
    Starts at sequence number 1 and has packet type &#39;iscontn&#39;.
    &#34;&#34;&#34;
    seq = (1).to_bytes(4, &#34;big&#34;)
    prev_mid = fid[:20]
    return Packet(fid, seq, prev_mid, payload,
                  pkt_type=PacketType.iscontn, skey=skey)


def create_succ(prev: Packet, payload: bytes, skey: bytes) -&gt; Packet:
    &#34;&#34;&#34;
    Creates and returns the successor of the given packet,
    containing the given payload.
    &#34;&#34;&#34;
    assert prev.mid is not None, &#34;previous packet must be signed&#34;
    seq = int.from_bytes(prev.seq, &#34;big&#34;) + 1
    return Packet(prev.fid, (seq).to_bytes(4, &#34;big&#34;),
                  prev.mid, payload, skey=skey)


def create_chain(fid: bytes, seq: bytes, prev_mid: bytes,
                 content: bytes, skey: bytes) -&gt; Tuple[Packet, List[Blob]]:
    &#34;&#34;&#34;
    Creates a blob chain, containing the given bytes.
    The blob is returned as a tuple, containing the header of the blob
    as a packet and a list containing Blob instances.
    Blob instances can easily be saved as bytes by using blob.wire.
    The blob list is empty if the content fits into the blob header.
    &#34;&#34;&#34;
    chain = []
    # get size as VarInt and prepend to content
    content = to_var_int(len(content)) + content

    # check if content fits into single blob
    num_fill = 28 - len(content)  # how many bytes left to fill content
    if num_fill &gt;= 0:
        # only one blob -&gt; null pointer at end
        header = content + bytes(num_fill)
        ptr = bytes(20)

    else:
        # pad message -&gt; divisible by 100
        header = content[:28]
        content = content[28:]
        pad = 100 - len(content) % 100
        content += bytes(pad)

        # start with last pkt
        ptr = bytes(20)
        while len(content) != 0:
            blob = Blob(content[-100:], ptr)
            chain.append(blob)
            # get next pointer
            ptr = blob.signature
            # cut content
            content = content[:-100]

    # create first pkt
    payload = header + ptr
    assert len(payload) == 48, &#34;blob header must be 48B&#34;
    pkt = Packet(fid, seq, prev_mid, payload,
                 pkt_type=PacketType.chain20, skey=skey)

    chain.reverse()
    return (pkt, chain)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="tinyssb.packet.create_chain"><code class="name flex">
<span>def <span class="ident">create_chain</span></span>(<span>fid: bytes, seq: bytes, prev_mid: bytes, content: bytes, skey: bytes) ‑> Tuple[<a title="tinyssb.packet.Packet" href="#tinyssb.packet.Packet">Packet</a>, List[<a title="tinyssb.packet.Blob" href="#tinyssb.packet.Blob">Blob</a>]]</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a blob chain, containing the given bytes.
The blob is returned as a tuple, containing the header of the blob
as a packet and a list containing Blob instances.
Blob instances can easily be saved as bytes by using blob.wire.
The blob list is empty if the content fits into the blob header.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_chain(fid: bytes, seq: bytes, prev_mid: bytes,
                 content: bytes, skey: bytes) -&gt; Tuple[Packet, List[Blob]]:
    &#34;&#34;&#34;
    Creates a blob chain, containing the given bytes.
    The blob is returned as a tuple, containing the header of the blob
    as a packet and a list containing Blob instances.
    Blob instances can easily be saved as bytes by using blob.wire.
    The blob list is empty if the content fits into the blob header.
    &#34;&#34;&#34;
    chain = []
    # get size as VarInt and prepend to content
    content = to_var_int(len(content)) + content

    # check if content fits into single blob
    num_fill = 28 - len(content)  # how many bytes left to fill content
    if num_fill &gt;= 0:
        # only one blob -&gt; null pointer at end
        header = content + bytes(num_fill)
        ptr = bytes(20)

    else:
        # pad message -&gt; divisible by 100
        header = content[:28]
        content = content[28:]
        pad = 100 - len(content) % 100
        content += bytes(pad)

        # start with last pkt
        ptr = bytes(20)
        while len(content) != 0:
            blob = Blob(content[-100:], ptr)
            chain.append(blob)
            # get next pointer
            ptr = blob.signature
            # cut content
            content = content[:-100]

    # create first pkt
    payload = header + ptr
    assert len(payload) == 48, &#34;blob header must be 48B&#34;
    pkt = Packet(fid, seq, prev_mid, payload,
                 pkt_type=PacketType.chain20, skey=skey)

    chain.reverse()
    return (pkt, chain)</code></pre>
</details>
</dd>
<dt id="tinyssb.packet.create_child_pkt"><code class="name flex">
<span>def <span class="ident">create_child_pkt</span></span>(<span>fid: bytes, payload: bytes, skey: bytes) ‑> <a title="tinyssb.packet.Packet" href="#tinyssb.packet.Packet">Packet</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates and returns the first packet of a new child feed.
Starts with sequence number 1 and has packet type 'ischild'.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_child_pkt(fid: bytes, payload: bytes, skey: bytes) -&gt; Packet:
    &#34;&#34;&#34;
    Creates and returns the first packet of a new child feed.
    Starts with sequence number 1 and has packet type &#39;ischild&#39;.
    &#34;&#34;&#34;
    seq = (1).to_bytes(4, &#34;big&#34;)
    prev_mid = fid[:20]
    return Packet(fid, seq, prev_mid, payload,
                  pkt_type=PacketType.ischild, skey=skey)</code></pre>
</details>
</dd>
<dt id="tinyssb.packet.create_contn_pkt"><code class="name flex">
<span>def <span class="ident">create_contn_pkt</span></span>(<span>fid: bytes, payload: bytes, skey: bytes) ‑> <a title="tinyssb.packet.Packet" href="#tinyssb.packet.Packet">Packet</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates and returns the first packet of a continuation feed.
Starts at sequence number 1 and has packet type 'iscontn'.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_contn_pkt(fid: bytes, payload: bytes, skey: bytes) -&gt; Packet:
    &#34;&#34;&#34;
    Creates and returns the first packet of a continuation feed.
    Starts at sequence number 1 and has packet type &#39;iscontn&#39;.
    &#34;&#34;&#34;
    seq = (1).to_bytes(4, &#34;big&#34;)
    prev_mid = fid[:20]
    return Packet(fid, seq, prev_mid, payload,
                  pkt_type=PacketType.iscontn, skey=skey)</code></pre>
</details>
</dd>
<dt id="tinyssb.packet.create_end_pkt"><code class="name flex">
<span>def <span class="ident">create_end_pkt</span></span>(<span>fid: bytes, seq: bytes, prev_mid: bytes, contn_fid: bytes, skey: bytes) ‑> <a title="tinyssb.packet.Packet" href="#tinyssb.packet.Packet">Packet</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates and returns the last packet of a feed.
Contains information of the continuing feed.
Has packet type 'contdas'.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_end_pkt(fid: bytes,
                   seq: bytes,
                   prev_mid: bytes,
                   contn_fid: bytes,
                   skey: bytes) -&gt; Packet:
    &#34;&#34;&#34;
    Creates and returns the last packet of a feed.
    Contains information of the continuing feed.
    Has packet type &#39;contdas&#39;.
    &#34;&#34;&#34;
    # TODO: add more info (time stamp?)
    return Packet(fid, seq, prev_mid, payload=contn_fid,
                  pkt_type=PacketType.contdas, skey=skey)</code></pre>
</details>
</dd>
<dt id="tinyssb.packet.create_genesis_pkt"><code class="name flex">
<span>def <span class="ident">create_genesis_pkt</span></span>(<span>fid: bytes, payload: bytes, skey: bytes) ‑> <a title="tinyssb.packet.Packet" href="#tinyssb.packet.Packet">Packet</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates and returns a 'self-signed' Packet instance
with sequence number 1.
Also contains a payload of max. 48B.
Used when creating new feeds.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_genesis_pkt(fid: bytes, payload: bytes, skey: bytes) -&gt; Packet:
    &#34;&#34;&#34;
    Creates and returns a &#39;self-signed&#39; Packet instance
    with sequence number 1.
    Also contains a payload of max. 48B.
    Used when creating new feeds.
    &#34;&#34;&#34;
    seq = (1).to_bytes(4, &#34;big&#34;)  # seq numbers start at 1
    prev_mid = fid[:20]  # tiny ssb convention
    return Packet(fid, seq, prev_mid, payload, skey=skey)</code></pre>
</details>
</dd>
<dt id="tinyssb.packet.create_parent_pkt"><code class="name flex">
<span>def <span class="ident">create_parent_pkt</span></span>(<span>fid: bytes, seq: bytes, prev_mid: bytes, child_fid: bytes, skey: bytes) ‑> <a title="tinyssb.packet.Packet" href="#tinyssb.packet.Packet">Packet</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates and returns a Packet instance of type 'mkchild'.
Is used in parent feed, to refer to child feed.
No payload can be attached to this packet,
as it contains information about the child feed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_parent_pkt(fid: bytes,
                      seq: bytes,
                      prev_mid: bytes,
                      child_fid: bytes,
                      skey: bytes) -&gt; Packet:
    &#34;&#34;&#34;
    Creates and returns a Packet instance of type &#39;mkchild&#39;.
    Is used in parent feed, to refer to child feed.
    No payload can be attached to this packet,
    as it contains information about the child feed.
    &#34;&#34;&#34;
    # TODO: add more info (time stamp?)
    return Packet(fid, seq, prev_mid, payload=child_fid,
                  pkt_type=PacketType.mkchild, skey=skey)</code></pre>
</details>
</dd>
<dt id="tinyssb.packet.create_succ"><code class="name flex">
<span>def <span class="ident">create_succ</span></span>(<span>prev: <a title="tinyssb.packet.Packet" href="#tinyssb.packet.Packet">Packet</a>, payload: bytes, skey: bytes) ‑> <a title="tinyssb.packet.Packet" href="#tinyssb.packet.Packet">Packet</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates and returns the successor of the given packet,
containing the given payload.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_succ(prev: Packet, payload: bytes, skey: bytes) -&gt; Packet:
    &#34;&#34;&#34;
    Creates and returns the successor of the given packet,
    containing the given payload.
    &#34;&#34;&#34;
    assert prev.mid is not None, &#34;previous packet must be signed&#34;
    seq = int.from_bytes(prev.seq, &#34;big&#34;) + 1
    return Packet(prev.fid, (seq).to_bytes(4, &#34;big&#34;),
                  prev.mid, payload, skey=skey)</code></pre>
</details>
</dd>
<dt id="tinyssb.packet.pkt_from_bytes"><code class="name flex">
<span>def <span class="ident">pkt_from_bytes</span></span>(<span>fid: bytes, seq: bytes, prev_mid: bytes, pkt_wire: bytes) ‑> Optional[<a title="tinyssb.packet.Packet" href="#tinyssb.packet.Packet">Packet</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a Packet instance from the given feed ID, sequence number
previous message ID and wire bytes.
Also validates the packet.
If the signatures do not match, 'None' is returned.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pkt_from_bytes(fid: bytes,
                   seq: bytes,
                   prev_mid: bytes,
                   pkt_wire: bytes) -&gt; Optional[Packet]:
    &#34;&#34;&#34;
    Creates a Packet instance from the given feed ID, sequence number
    previous message ID and wire bytes.
    Also validates the packet.
    If the signatures do not match, &#39;None&#39; is returned.
    &#34;&#34;&#34;
    assert len(pkt_wire) == 120, &#34;length of packet wire format must be 120B&#34;
    assert len(fid) == 32, &#34;feed id must be 32B&#34;

    # dmx = raw_pkt[:7]
    pkt_type = pkt_wire[7:8]
    payload = pkt_wire[8:56]
    signature = pkt_wire[56:]

    # create unsigned Packet
    pkt = Packet(fid, seq, prev_mid, payload, pkt_type=pkt_type)

    # use fid as verification key
    if verify_elliptic(pkt._expand(), signature, fid):
        # verification successful
        # fill-in signature and calculate missing info
        pkt.signature = signature
        pkt.mid = pkt._calc_mid()
        pkt.wire = pkt_wire
        return pkt
    else:
        print(&#34;packet not trusted&#34;)
        return None</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="tinyssb.packet.Blob"><code class="flex name class">
<span>class <span class="ident">Blob</span></span>
<span>(</span><span>payload: bytes, ptr: bytes)</span>
</code></dt>
<dd>
<div class="desc"><p>Simple class for handling blob information.
Not used for first blob entry (Packet).
Uses sha256 for generating pointers to next blob.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Blob:
    &#34;&#34;&#34;
    Simple class for handling blob information.
    Not used for first blob entry (Packet).
    Uses sha256 for generating pointers to next blob.
    &#34;&#34;&#34;
    def __init__(self, payload: bytes, ptr: bytes):
        self.payload = payload
        self.ptr = ptr
        self.wire = payload + ptr
        self.signature = hashlib.sha256(self.wire).digest()[:20]</code></pre>
</details>
</dd>
<dt id="tinyssb.packet.Packet"><code class="flex name class">
<span>class <span class="ident">Packet</span></span>
<span>(</span><span>fid: bytes, seq: bytes, prev_mid: bytes, payload: bytes = b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00', pkt_type: bytes = b'\x00', skey: Optional[bytes] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>As defined in the tiny sbb protocol.
Contains physical and virtual information.
The maximum payload size of a packet is 48B.
Uses ed25519 for signing and verifying Packets.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Packet:
    &#34;&#34;&#34;
    As defined in the tiny sbb protocol.
    Contains physical and virtual information.
    The maximum payload size of a packet is 48B.
    Uses ed25519 for signing and verifying Packets.
    &#34;&#34;&#34;
    prefix = b&#34;tiny-v01&#34;  # length must be 8B

    def __init__(self,
                 fid: bytes,
                 seq: bytes,
                 prev_mid: bytes,
                 payload: bytes = bytes(48),
                 pkt_type: bytes = PacketType.plain48,  # default
                 skey: Optional[bytes] = None):

        # check arguments
        assert len(fid) == 32, &#34;feed ID must be 32B&#34;
        assert len(seq) == 4, &#34;sequence number must be 4B&#34;
        assert len(prev_mid) == 20, &#34;previous msg_id must be 20B&#34;
        assert (skey is None or
                len(skey) == 32), &#34;skey must be 32B or None&#34;

        # make sure that payload is 48 bytes, rejected if too long
        if len(payload) &lt; 48:
            # too short -&gt; append 0s
            missing = 48 - len(payload)
            payload += bytes(missing)
        assert len(payload) == 48, &#34;payload must be 48B&#34;

        # build packet
        self.block_name = self.prefix + fid + seq + prev_mid
        self.fid = fid
        self.seq = seq
        self.prev_mid = prev_mid
        self.payload = payload
        self.pkt_type = pkt_type
        self.skey = skey
        self.dmx = self._calc_dmx()

        # sign, if possible
        if self.skey is None:
            self.signature = None
            self.mid = None
            self.wire = None
        else:
            self.signature = self._calc_signature()
            self.mid = self._calc_mid()
            self.wire = self._get_wire()

    def __repr__(self):
        s = &#34;Packet\n&#34;
        s += &#34;------\n&#34;
        s += &#34;fid:\t{}\n&#34;.format(self.fid)
        s += &#34;seq:\t{}\n&#34;.format(self.seq)
        s += &#34;prev_mid:\t{}\n&#34;.format(self.prev_mid)
        s += &#34;payload:\t{}\n&#34;.format(self.payload)
        s += &#34;type:\t{}\n&#34;.format(self.pkt_type)
        s += &#34;mid:\t{}\n&#34;.format(self.mid)
        s += &#34;signature:\t{}&#34;.format(self.signature)
        return s

    def _calc_dmx(self) -&gt; bytes:
        &#34;&#34;&#34;
        Calculates the demultiplexing field of the packet.
        &#34;&#34;&#34;
        return hashlib.sha256(self.block_name).digest()[:7]

    def next_dmx(self) -&gt; bytes:
        &#34;&#34;&#34;
        Predicts the next packet&#39;s dmx value.
        &#34;&#34;&#34;
        assert self.mid is not None, &#34;sign packet first&#34;

        next_seq = int.from_bytes(self.seq, &#34;big&#34;) + 1
        next = self.prefix + self.fid + next_seq.to_bytes(4, &#34;big&#34;) + self.mid
        return hashlib.sha256(next).digest()[:20]

    def _expand(self) -&gt; bytes:
        &#34;&#34;&#34;
        Computes the 128B expanded block containing &#39;virtual&#39; information.
        &#34;&#34;&#34;
        return self.block_name + self.dmx + self.pkt_type + self.payload

    def _calc_signature(self) -&gt; bytes:
        &#34;&#34;&#34;
        Computes the signature of the packet using the ed25519 algorithm..
        &#34;&#34;&#34;
        assert self.skey is not None, &#34;key needed for signing&#34;
        return sign_elliptic(self.skey, self._expand())

    def _get_full(self) -&gt; bytes:
        &#34;&#34;&#34;
        Computes the full 184B block.
        Consists of the expanded block and
        the signature of the packet.
        &#34;&#34;&#34;
        if self.signature is not None:
            # signature already calculated
            return self._expand() + self.signature
        return self._expand() + self._calc_signature()

    def _calc_mid(self) -&gt; bytes:
        &#34;&#34;&#34;
        Computes the 20B message ID of the packet.
        This message ID is referenced in the next packet.
        &#34;&#34;&#34;
        return hashlib.sha256(self._get_full()).digest()[:20]

    def _get_wire(self) -&gt; bytes:
        &#34;&#34;&#34;
        Returns the 120B &#39;raw&#39; wire format of the packet.
        The missing &#39;virtual&#39; information can be inferred by
        the recipient using prior packets.
        &#34;&#34;&#34;
        assert self.signature is not None, &#34;sign packet first&#34;
        return self.dmx + self.pkt_type + self.payload + self.signature

    def sign(self, skey: bytes = bytes(32)) -&gt; None:
        &#34;&#34;&#34;Calculates the signature of the Packet and all the related fields
        using the given signing key.
        For testing, the default key is 32 0s.&#34;&#34;&#34;
        assert len(skey) == 32, &#34;skey must be 32B&#34;
        self.skey = skey
        self.signature = self._calc_signature()
        self.mid = self._calc_mid()
        self.wire = self._get_wire()</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="tinyssb.packet.Packet.prefix"><code class="name">var <span class="ident">prefix</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="tinyssb.packet.Packet.next_dmx"><code class="name flex">
<span>def <span class="ident">next_dmx</span></span>(<span>self) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Predicts the next packet's dmx value.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def next_dmx(self) -&gt; bytes:
    &#34;&#34;&#34;
    Predicts the next packet&#39;s dmx value.
    &#34;&#34;&#34;
    assert self.mid is not None, &#34;sign packet first&#34;

    next_seq = int.from_bytes(self.seq, &#34;big&#34;) + 1
    next = self.prefix + self.fid + next_seq.to_bytes(4, &#34;big&#34;) + self.mid
    return hashlib.sha256(next).digest()[:20]</code></pre>
</details>
</dd>
<dt id="tinyssb.packet.Packet.sign"><code class="name flex">
<span>def <span class="ident">sign</span></span>(<span>self, skey: bytes = b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00') ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates the signature of the Packet and all the related fields
using the given signing key.
For testing, the default key is 32 0s.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sign(self, skey: bytes = bytes(32)) -&gt; None:
    &#34;&#34;&#34;Calculates the signature of the Packet and all the related fields
    using the given signing key.
    For testing, the default key is 32 0s.&#34;&#34;&#34;
    assert len(skey) == 32, &#34;skey must be 32B&#34;
    self.skey = skey
    self.signature = self._calc_signature()
    self.mid = self._calc_mid()
    self.wire = self._get_wire()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="tinyssb.packet.PacketType"><code class="flex name class">
<span>class <span class="ident">PacketType</span></span>
</code></dt>
<dd>
<div class="desc"><p>Enum containing different packet types
(as defined in tiny-ssb protocol).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PacketType:
    &#34;&#34;&#34;
    Enum containing different packet types
    (as defined in tiny-ssb protocol).
    &#34;&#34;&#34;
    plain48 = bytes([0x00])  # sha256 HMAC signature, signle packet with 48B
    chain20 = bytes([0x01])  # sha256 HMAC signature, start of hash sidechain
    ischild = bytes([0x02])  # metafeed information, only in genesis block
    iscontn = bytes([0x03])  # metafeed information, only in genesis block
    mkchild = bytes([0x04])  # metafeed information
    contdas = bytes([0x05])  # metafeed information
    types = [plain48, chain20, ischild, iscontn, mkchild, contdas]

    @classmethod
    def is_type(cls, t: bytes) -&gt; bool:
        &#34;&#34;&#34;
        Returns True if there exists a packet type with the same
        number as the given int.
        &#34;&#34;&#34;
        return t in cls.types</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="tinyssb.packet.PacketType.chain20"><code class="name">var <span class="ident">chain20</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="tinyssb.packet.PacketType.contdas"><code class="name">var <span class="ident">contdas</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="tinyssb.packet.PacketType.ischild"><code class="name">var <span class="ident">ischild</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="tinyssb.packet.PacketType.iscontn"><code class="name">var <span class="ident">iscontn</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="tinyssb.packet.PacketType.mkchild"><code class="name">var <span class="ident">mkchild</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="tinyssb.packet.PacketType.plain48"><code class="name">var <span class="ident">plain48</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="tinyssb.packet.PacketType.types"><code class="name">var <span class="ident">types</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="tinyssb.packet.PacketType.is_type"><code class="name flex">
<span>def <span class="ident">is_type</span></span>(<span>t: bytes) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True if there exists a packet type with the same
number as the given int.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def is_type(cls, t: bytes) -&gt; bool:
    &#34;&#34;&#34;
    Returns True if there exists a packet type with the same
    number as the given int.
    &#34;&#34;&#34;
    return t in cls.types</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="tinyssb" href="index.html">tinyssb</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="tinyssb.packet.create_chain" href="#tinyssb.packet.create_chain">create_chain</a></code></li>
<li><code><a title="tinyssb.packet.create_child_pkt" href="#tinyssb.packet.create_child_pkt">create_child_pkt</a></code></li>
<li><code><a title="tinyssb.packet.create_contn_pkt" href="#tinyssb.packet.create_contn_pkt">create_contn_pkt</a></code></li>
<li><code><a title="tinyssb.packet.create_end_pkt" href="#tinyssb.packet.create_end_pkt">create_end_pkt</a></code></li>
<li><code><a title="tinyssb.packet.create_genesis_pkt" href="#tinyssb.packet.create_genesis_pkt">create_genesis_pkt</a></code></li>
<li><code><a title="tinyssb.packet.create_parent_pkt" href="#tinyssb.packet.create_parent_pkt">create_parent_pkt</a></code></li>
<li><code><a title="tinyssb.packet.create_succ" href="#tinyssb.packet.create_succ">create_succ</a></code></li>
<li><code><a title="tinyssb.packet.pkt_from_bytes" href="#tinyssb.packet.pkt_from_bytes">pkt_from_bytes</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="tinyssb.packet.Blob" href="#tinyssb.packet.Blob">Blob</a></code></h4>
</li>
<li>
<h4><code><a title="tinyssb.packet.Packet" href="#tinyssb.packet.Packet">Packet</a></code></h4>
<ul class="">
<li><code><a title="tinyssb.packet.Packet.next_dmx" href="#tinyssb.packet.Packet.next_dmx">next_dmx</a></code></li>
<li><code><a title="tinyssb.packet.Packet.prefix" href="#tinyssb.packet.Packet.prefix">prefix</a></code></li>
<li><code><a title="tinyssb.packet.Packet.sign" href="#tinyssb.packet.Packet.sign">sign</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="tinyssb.packet.PacketType" href="#tinyssb.packet.PacketType">PacketType</a></code></h4>
<ul class="two-column">
<li><code><a title="tinyssb.packet.PacketType.chain20" href="#tinyssb.packet.PacketType.chain20">chain20</a></code></li>
<li><code><a title="tinyssb.packet.PacketType.contdas" href="#tinyssb.packet.PacketType.contdas">contdas</a></code></li>
<li><code><a title="tinyssb.packet.PacketType.is_type" href="#tinyssb.packet.PacketType.is_type">is_type</a></code></li>
<li><code><a title="tinyssb.packet.PacketType.ischild" href="#tinyssb.packet.PacketType.ischild">ischild</a></code></li>
<li><code><a title="tinyssb.packet.PacketType.iscontn" href="#tinyssb.packet.PacketType.iscontn">iscontn</a></code></li>
<li><code><a title="tinyssb.packet.PacketType.mkchild" href="#tinyssb.packet.PacketType.mkchild">mkchild</a></code></li>
<li><code><a title="tinyssb.packet.PacketType.plain48" href="#tinyssb.packet.PacketType.plain48">plain48</a></code></li>
<li><code><a title="tinyssb.packet.PacketType.types" href="#tinyssb.packet.PacketType.types">types</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>