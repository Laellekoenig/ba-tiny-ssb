<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>feed API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>feed</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import os
from packet import Blob
from packet import Packet
from packet import PacketType
from packet import create_chain
from packet import pkt_from_bytes
from ssb_util import from_var_int
from ssb_util import is_file
from ssb_util import to_hex


class Feed:
    &#34;&#34;&#34;
    Represents a .log file.
    Used to get/append data from/to feeds.
    &#34;&#34;&#34;

    def __init__(self, file_name: str, skey: bytes = None):
        self.file_name = file_name
        f = open(self.file_name, &#34;rb&#34;)
        header = f.read(128)
        f.close()
        self.skey = skey

        # reserved = header[:12]
        self.fid = header[12:44]
        self.parent_id = header[44:76]
        self.parent_seq = int.from_bytes(header[76:80], &#34;big&#34;)
        self.anchor_seq = int.from_bytes(header[80:84], &#34;big&#34;)
        self.anchor_mid = header[84:104]
        self.front_seq = int.from_bytes(header[104:108], &#34;big&#34;)
        self.front_mid = header[108:128]

    def __len__(self) -&gt; int:
        return self.front_seq

    def __getitem__(self, seq: int) -&gt; bytes:
        &#34;&#34;&#34;
        Returns the payload of the packet with the corresponding
        sequence number.
        Negative indices access the feed from behind.
        The packet is NOT validated before the payload is returned.
        Also returns full blobs, without verifying.
        &#34;&#34;&#34;
        raw_pkt = self.get_raw_pkt(seq)
        # dmx = raw_pkt[:7]
        pkt_type = raw_pkt[7:8]
        payload = raw_pkt[8:56]
        if pkt_type != PacketType.chain20:
            return payload

        # blob chain
        size, num_bytes = from_var_int(payload)
        content = payload[num_bytes:-20]

        ptr = payload[-20:]
        while ptr != bytes(20):
            blob = self._get_blob(ptr)
            assert blob is not None, &#34;failed to extract blob chain&#34;
            ptr = blob.ptr
            content += blob.payload

        return content[:size]

    def get_raw_pkt(self, seq: int) -&gt; bytes:
        &#34;&#34;&#34;
        Returns the raw packet as bytes.
        The raw packet consists of 8B placeholder and 120B packet wire format.
        &#34;&#34;&#34;
        if seq &lt; 0:
            seq = self.front_seq + seq + 1  # access last pkt through -1 etc.
        if seq &gt; self.front_seq or seq &lt;= self.anchor_seq:
            raise IndexError

        relative_i = seq- self.anchor_seq
        f = open(self.file_name, &#34;rb&#34;)
        f.seek(128 * relative_i)
        raw_pkt = f.read(128)[8:]  # cut off reserved 8B
        f.close()

        return raw_pkt

    def get_pkt_type(self, seq: int) -&gt; bytes:
        &#34;&#34;&#34;
        Returns the type of the packet with given index.
        Bytes can be compared with PacketTypes.
        &#34;&#34;&#34;
        raw_pkt = self.get_raw_pkt(seq)
        pkt_type = raw_pkt[7:8]
        types = [PacketType.chain20, PacketType.contdas, PacketType.ischild,
                 PacketType.mkchild]
        try:
            return types[types.index(pkt_type)]
        except Exception:
            return None

    def __iter__(self):
        self._n = self.anchor_seq
        return self

    def __next__(self) -&gt; bytes:
        self._n += 1
        if self._n &gt; self.front_seq:
            raise StopIteration

        payload = self[self._n]
        return payload

    def get(self, i: int) -&gt; bytes:
        &#34;&#34;&#34;
        Returns Packet instance with corresponding sequence number in feed.
        Identical to __getitem__.
        &#34;&#34;&#34;
        return self[i]

    def _update_header(self) -&gt; None:
        &#34;&#34;&#34;
        Updates the front sequence number and message ID in the .log file
        with the current values of the instance.
        &#34;&#34;&#34;
        assert type(self.front_mid) is bytes
        new_info = self.front_seq.to_bytes(4, &#34;big&#34;) + self.front_mid
        assert len(new_info) == 24, &#34;new front seq and mid must be 24B&#34;
        # go to beginning of file + 104B (where front seq and mid are)
        # this is not ideal, since the whole file has to be copied to memory
        # this is due to some weird behaviour of micropython
        f = open(self.file_name, &#34;rb+&#34;)
        f.seek(0)
        file_content = f.read()
        updated_content = file_content[:104] + new_info + file_content[128:]
        f.seek(0)
        f.write(updated_content)
        f.close()

    def append_pkt(self, pkt: Packet) -&gt; bool:
        &#34;&#34;&#34;
        Appends given packet to .log file and updates
        front sequence number and message ID.
        Returns &#39;True&#39; on success.
        If the feed has ended, nothing is appended and
        False is returned.
        &#34;&#34;&#34;
        if self.has_ended():
            print(&#34;cannot append to finished feed&#34;)
            return False

        # TODO: better error handling
        if pkt is None:
            return False

        # go to end of buffer and write
        assert pkt.wire is not None, &#34;packet must be signed before appended&#34;
        payload = bytes(8) + pkt.wire
        assert len(payload) == 128, &#34;wire pkt must be 128B&#34;

        f = open(self.file_name, &#34;rb+&#34;)
        f.seek(0, 2)
        f.write(payload)  # pappend 8B reserved
        f.close()

        # update header info
        self.front_seq += 1
        self.front_mid = pkt.mid
        self._update_header()
        return True

    def append_bytes(self, payload: bytes) -&gt; bool:
        &#34;&#34;&#34;
        Creates a regular packet containing the given payload
        and appends it to the feed.
        Returns &#39;True&#39; on success.
        If the feed has ended, nothing is appended and
        False is returned.
        &#34;&#34;&#34;
        next_seq = self.front_seq + 1
        assert self.front_mid is not None
        assert self.skey is not None, &#34;can only append if signing key known&#34;
        pkt = Packet(self.fid, next_seq.to_bytes(4, &#34;big&#34;),
                     self.front_mid, payload, skey=self.skey)
        if pkt is None:
            return False

        return self.append_pkt(pkt)

    def verify_and_append_bytes(self, raw_pkt: bytes) -&gt; bool:
        &#34;&#34;&#34;
        Creates a new packet from the raw bytes and attempts to validate it.
        Uses the feed_id as validation key.
        If the packet does not validate, False is returned.
        &#34;&#34;&#34;
        seq = (self.front_seq + 1).to_bytes(4, &#34;big&#34;)
        assert self.front_mid is not None
        pkt = pkt_from_bytes(self.fid, seq, self.front_mid, raw_pkt)

        if pkt is None:
            return False

        return self.append_pkt(pkt)

    def append_blob(self, payload: bytes) -&gt; bool:
        &#34;&#34;&#34;
        Creates a blob from the provided payload.
        A packet of type &#39;chain20&#39; is appended to the feed,
        referring to the blob files (in _blob directory).
        If the feed has ended, nothing is appended and
        False is returned.
        &#34;&#34;&#34;
        next_seq = (self.front_seq + 1).to_bytes(4, &#34;big&#34;)
        assert self.front_mid is not None
        assert self.skey is not None, &#34;can only append if signing key is known&#34;
        pkt, blobs = create_chain(self.fid, next_seq,
                                  self.front_mid, payload,
                                  self.skey)

        if pkt is None:
            return False

        self.append_pkt(pkt)
        return self._write_blob(blobs)

    def _write_blob(self, blobs: list[Blob]) -&gt; bool:
        &#34;&#34;&#34;
        Takes a list of blob instances and writes them
        to blob files, as defined in tiny-ssb protocol.
        Returns &#39;True&#39; on success.
        &#34;&#34;&#34;
        # get path of _blobs folder
        split = self.file_name.split(&#34;/&#34;)
        path = &#34;/&#34;.join(split[:-2]) + &#34;_blobs/&#34;

        for blob in blobs:
            hash_hex = to_hex(blob.signature)
            dir_path = path + hash_hex[:2]
            file_name = dir_path + &#34;/&#34; + hash_hex[2:]
            if not is_file(dir_path):
                os.mkdir(dir_path)
            try:
                f = open(file_name, &#34;wb&#34;)
                f.write(blob.wire)
                f.close()
            except Exception:
                return False
        return True

    def _get_blob(self, ptr: bytes) -&gt; Blob:
        &#34;&#34;&#34;
        Creates and returns a blob instance of the
        blob file that the given pointer is pointing to.
        &#34;&#34;&#34;
        # get path of _blobs folder
        hex_hash = to_hex(ptr)
        split = self.file_name.split(&#34;/&#34;)
        file_name = &#34;/&#34;.join(split[:-2]) + &#34;_blobs/&#34; + hex_hash[:2]
        file_name += &#34;/&#34; + hex_hash[2:]

        try:
            f = open(file_name, &#34;rb&#34;)
            content = f.read(120)
            f.close()
        except Exception:
            return None

        assert len(content) == 120, &#34;blob must be 120B&#34;
        return Blob(content[:100], content[100:])

    def get_blob_chain(self, pkt: Packet) -&gt; bytes:
        &#34;&#34;&#34;
        Retrieves the full data that a &#39;chain20&#39; packet is pointing to.
        The content is validated.
        If validation fails, &#39;None&#39; is returned.
        &#34;&#34;&#34;
        assert pkt.pkt_type == PacketType.chain20, &#34;pkt type must be chain20&#34;

        blobs = []
        ptr = pkt.payload[-20:]
        while ptr != bytes(20):
            blob = self._get_blob(ptr)
            assert blob is not None, &#34;chaining of blobs failed&#34;
            ptr = blob.ptr
            blobs.append(blob)

        return self._verify_chain(pkt, blobs)

    def _verify_chain(self, head: Packet, blobs: list[Blob]) -&gt; bytes:
        &#34;&#34;&#34;
        Verifies the authenticity of a given blob chain.
        If it is valid, the content is returned as bytes.
        &#34;&#34;&#34;
        size, num_bytes = from_var_int(head.payload)
        ptr = head.payload[-20:]
        content = head.payload[num_bytes:-20]

        for blob in blobs:
            if ptr != blob.signature:
                return None
            content += blob.payload
            ptr = blob.ptr

        return content[:size]

    def has_ended(self) -&gt; bool:
        &#34;&#34;&#34;
        Returns &#39;True&#39; if the feed was ended by a &#39;contdas&#39; packet.
        &#34;&#34;&#34;
        if len(self) &lt; 1:
            return False
        return self.get_pkt_type(-1) == PacketType.contdas

    def get_parent(self) -&gt; bytes:
        &#34;&#34;&#34;
        Returns the feed ID of this feed&#39;s parent feed.
        If this is not a child feed, &#39;None&#39; is returned.
        &#34;&#34;&#34;
        if self.anchor_seq != 0:
            return None

        if self.get_pkt_type(1) != PacketType.ischild:
            return None

        # parent fid == first 32B of payload in first pkt
        return self[1][:32]

    def get_children(self) -&gt; list[bytes]:
        &#34;&#34;&#34;
        Returns a list of all child feed IDs contained
        within this feed.
        &#34;&#34;&#34;
        children = []
        for i in range(self.anchor_seq + 1, self.front_seq + 1):
            if self.get_pkt_type(i) == PacketType.mkchild:
                children.append(self[i][:32])

        return children

    def get_contn(self) -&gt; bytes:
        &#34;&#34;&#34;
        Returns the feed ID of this feed&#39;s continuation feed.
        If this feed has not ended, &#39;None&#39; is returned.
        &#34;&#34;&#34;
        if self.get_pkt_type(-1) == PacketType.contdas:
            return self[-1][:32]
        else:
            return None

    def get_prev(self) -&gt; bytes:
        &#34;&#34;&#34;
        Returns the feed ID of this feed&#39;s predecessor feed.
        If this feed does not have a predecessor, &#39;None&#39; is returned.
        &#34;&#34;&#34;
        if self.anchor_seq != 0:
            return None

        if self.get_pkt_type(1) == PacketType.iscontn:
            return self[1][:32]
        else:
            return None

    def get_front(self) -&gt; tuple[int, bytes]:
        &#34;&#34;&#34;
        Returns this feed&#39;s front sequence number and front message ID
        in a tuple.
        &#34;&#34;&#34;
        assert self.front_mid is not None
        return (self.front_seq, self.front_mid)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="feed.Feed"><code class="flex name class">
<span>class <span class="ident">Feed</span></span>
<span>(</span><span>file_name: str, skey: bytes = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Represents a .log file.
Used to get/append data from/to feeds.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Feed:
    &#34;&#34;&#34;
    Represents a .log file.
    Used to get/append data from/to feeds.
    &#34;&#34;&#34;

    def __init__(self, file_name: str, skey: bytes = None):
        self.file_name = file_name
        f = open(self.file_name, &#34;rb&#34;)
        header = f.read(128)
        f.close()
        self.skey = skey

        # reserved = header[:12]
        self.fid = header[12:44]
        self.parent_id = header[44:76]
        self.parent_seq = int.from_bytes(header[76:80], &#34;big&#34;)
        self.anchor_seq = int.from_bytes(header[80:84], &#34;big&#34;)
        self.anchor_mid = header[84:104]
        self.front_seq = int.from_bytes(header[104:108], &#34;big&#34;)
        self.front_mid = header[108:128]

    def __len__(self) -&gt; int:
        return self.front_seq

    def __getitem__(self, seq: int) -&gt; bytes:
        &#34;&#34;&#34;
        Returns the payload of the packet with the corresponding
        sequence number.
        Negative indices access the feed from behind.
        The packet is NOT validated before the payload is returned.
        Also returns full blobs, without verifying.
        &#34;&#34;&#34;
        raw_pkt = self.get_raw_pkt(seq)
        # dmx = raw_pkt[:7]
        pkt_type = raw_pkt[7:8]
        payload = raw_pkt[8:56]
        if pkt_type != PacketType.chain20:
            return payload

        # blob chain
        size, num_bytes = from_var_int(payload)
        content = payload[num_bytes:-20]

        ptr = payload[-20:]
        while ptr != bytes(20):
            blob = self._get_blob(ptr)
            assert blob is not None, &#34;failed to extract blob chain&#34;
            ptr = blob.ptr
            content += blob.payload

        return content[:size]

    def get_raw_pkt(self, seq: int) -&gt; bytes:
        &#34;&#34;&#34;
        Returns the raw packet as bytes.
        The raw packet consists of 8B placeholder and 120B packet wire format.
        &#34;&#34;&#34;
        if seq &lt; 0:
            seq = self.front_seq + seq + 1  # access last pkt through -1 etc.
        if seq &gt; self.front_seq or seq &lt;= self.anchor_seq:
            raise IndexError

        relative_i = seq- self.anchor_seq
        f = open(self.file_name, &#34;rb&#34;)
        f.seek(128 * relative_i)
        raw_pkt = f.read(128)[8:]  # cut off reserved 8B
        f.close()

        return raw_pkt

    def get_pkt_type(self, seq: int) -&gt; bytes:
        &#34;&#34;&#34;
        Returns the type of the packet with given index.
        Bytes can be compared with PacketTypes.
        &#34;&#34;&#34;
        raw_pkt = self.get_raw_pkt(seq)
        pkt_type = raw_pkt[7:8]
        types = [PacketType.chain20, PacketType.contdas, PacketType.ischild,
                 PacketType.mkchild]
        try:
            return types[types.index(pkt_type)]
        except Exception:
            return None

    def __iter__(self):
        self._n = self.anchor_seq
        return self

    def __next__(self) -&gt; bytes:
        self._n += 1
        if self._n &gt; self.front_seq:
            raise StopIteration

        payload = self[self._n]
        return payload

    def get(self, i: int) -&gt; bytes:
        &#34;&#34;&#34;
        Returns Packet instance with corresponding sequence number in feed.
        Identical to __getitem__.
        &#34;&#34;&#34;
        return self[i]

    def _update_header(self) -&gt; None:
        &#34;&#34;&#34;
        Updates the front sequence number and message ID in the .log file
        with the current values of the instance.
        &#34;&#34;&#34;
        assert type(self.front_mid) is bytes
        new_info = self.front_seq.to_bytes(4, &#34;big&#34;) + self.front_mid
        assert len(new_info) == 24, &#34;new front seq and mid must be 24B&#34;
        # go to beginning of file + 104B (where front seq and mid are)
        # this is not ideal, since the whole file has to be copied to memory
        # this is due to some weird behaviour of micropython
        f = open(self.file_name, &#34;rb+&#34;)
        f.seek(0)
        file_content = f.read()
        updated_content = file_content[:104] + new_info + file_content[128:]
        f.seek(0)
        f.write(updated_content)
        f.close()

    def append_pkt(self, pkt: Packet) -&gt; bool:
        &#34;&#34;&#34;
        Appends given packet to .log file and updates
        front sequence number and message ID.
        Returns &#39;True&#39; on success.
        If the feed has ended, nothing is appended and
        False is returned.
        &#34;&#34;&#34;
        if self.has_ended():
            print(&#34;cannot append to finished feed&#34;)
            return False

        # TODO: better error handling
        if pkt is None:
            return False

        # go to end of buffer and write
        assert pkt.wire is not None, &#34;packet must be signed before appended&#34;
        payload = bytes(8) + pkt.wire
        assert len(payload) == 128, &#34;wire pkt must be 128B&#34;

        f = open(self.file_name, &#34;rb+&#34;)
        f.seek(0, 2)
        f.write(payload)  # pappend 8B reserved
        f.close()

        # update header info
        self.front_seq += 1
        self.front_mid = pkt.mid
        self._update_header()
        return True

    def append_bytes(self, payload: bytes) -&gt; bool:
        &#34;&#34;&#34;
        Creates a regular packet containing the given payload
        and appends it to the feed.
        Returns &#39;True&#39; on success.
        If the feed has ended, nothing is appended and
        False is returned.
        &#34;&#34;&#34;
        next_seq = self.front_seq + 1
        assert self.front_mid is not None
        assert self.skey is not None, &#34;can only append if signing key known&#34;
        pkt = Packet(self.fid, next_seq.to_bytes(4, &#34;big&#34;),
                     self.front_mid, payload, skey=self.skey)
        if pkt is None:
            return False

        return self.append_pkt(pkt)

    def verify_and_append_bytes(self, raw_pkt: bytes) -&gt; bool:
        &#34;&#34;&#34;
        Creates a new packet from the raw bytes and attempts to validate it.
        Uses the feed_id as validation key.
        If the packet does not validate, False is returned.
        &#34;&#34;&#34;
        seq = (self.front_seq + 1).to_bytes(4, &#34;big&#34;)
        assert self.front_mid is not None
        pkt = pkt_from_bytes(self.fid, seq, self.front_mid, raw_pkt)

        if pkt is None:
            return False

        return self.append_pkt(pkt)

    def append_blob(self, payload: bytes) -&gt; bool:
        &#34;&#34;&#34;
        Creates a blob from the provided payload.
        A packet of type &#39;chain20&#39; is appended to the feed,
        referring to the blob files (in _blob directory).
        If the feed has ended, nothing is appended and
        False is returned.
        &#34;&#34;&#34;
        next_seq = (self.front_seq + 1).to_bytes(4, &#34;big&#34;)
        assert self.front_mid is not None
        assert self.skey is not None, &#34;can only append if signing key is known&#34;
        pkt, blobs = create_chain(self.fid, next_seq,
                                  self.front_mid, payload,
                                  self.skey)

        if pkt is None:
            return False

        self.append_pkt(pkt)
        return self._write_blob(blobs)

    def _write_blob(self, blobs: list[Blob]) -&gt; bool:
        &#34;&#34;&#34;
        Takes a list of blob instances and writes them
        to blob files, as defined in tiny-ssb protocol.
        Returns &#39;True&#39; on success.
        &#34;&#34;&#34;
        # get path of _blobs folder
        split = self.file_name.split(&#34;/&#34;)
        path = &#34;/&#34;.join(split[:-2]) + &#34;_blobs/&#34;

        for blob in blobs:
            hash_hex = to_hex(blob.signature)
            dir_path = path + hash_hex[:2]
            file_name = dir_path + &#34;/&#34; + hash_hex[2:]
            if not is_file(dir_path):
                os.mkdir(dir_path)
            try:
                f = open(file_name, &#34;wb&#34;)
                f.write(blob.wire)
                f.close()
            except Exception:
                return False
        return True

    def _get_blob(self, ptr: bytes) -&gt; Blob:
        &#34;&#34;&#34;
        Creates and returns a blob instance of the
        blob file that the given pointer is pointing to.
        &#34;&#34;&#34;
        # get path of _blobs folder
        hex_hash = to_hex(ptr)
        split = self.file_name.split(&#34;/&#34;)
        file_name = &#34;/&#34;.join(split[:-2]) + &#34;_blobs/&#34; + hex_hash[:2]
        file_name += &#34;/&#34; + hex_hash[2:]

        try:
            f = open(file_name, &#34;rb&#34;)
            content = f.read(120)
            f.close()
        except Exception:
            return None

        assert len(content) == 120, &#34;blob must be 120B&#34;
        return Blob(content[:100], content[100:])

    def get_blob_chain(self, pkt: Packet) -&gt; bytes:
        &#34;&#34;&#34;
        Retrieves the full data that a &#39;chain20&#39; packet is pointing to.
        The content is validated.
        If validation fails, &#39;None&#39; is returned.
        &#34;&#34;&#34;
        assert pkt.pkt_type == PacketType.chain20, &#34;pkt type must be chain20&#34;

        blobs = []
        ptr = pkt.payload[-20:]
        while ptr != bytes(20):
            blob = self._get_blob(ptr)
            assert blob is not None, &#34;chaining of blobs failed&#34;
            ptr = blob.ptr
            blobs.append(blob)

        return self._verify_chain(pkt, blobs)

    def _verify_chain(self, head: Packet, blobs: list[Blob]) -&gt; bytes:
        &#34;&#34;&#34;
        Verifies the authenticity of a given blob chain.
        If it is valid, the content is returned as bytes.
        &#34;&#34;&#34;
        size, num_bytes = from_var_int(head.payload)
        ptr = head.payload[-20:]
        content = head.payload[num_bytes:-20]

        for blob in blobs:
            if ptr != blob.signature:
                return None
            content += blob.payload
            ptr = blob.ptr

        return content[:size]

    def has_ended(self) -&gt; bool:
        &#34;&#34;&#34;
        Returns &#39;True&#39; if the feed was ended by a &#39;contdas&#39; packet.
        &#34;&#34;&#34;
        if len(self) &lt; 1:
            return False
        return self.get_pkt_type(-1) == PacketType.contdas

    def get_parent(self) -&gt; bytes:
        &#34;&#34;&#34;
        Returns the feed ID of this feed&#39;s parent feed.
        If this is not a child feed, &#39;None&#39; is returned.
        &#34;&#34;&#34;
        if self.anchor_seq != 0:
            return None

        if self.get_pkt_type(1) != PacketType.ischild:
            return None

        # parent fid == first 32B of payload in first pkt
        return self[1][:32]

    def get_children(self) -&gt; list[bytes]:
        &#34;&#34;&#34;
        Returns a list of all child feed IDs contained
        within this feed.
        &#34;&#34;&#34;
        children = []
        for i in range(self.anchor_seq + 1, self.front_seq + 1):
            if self.get_pkt_type(i) == PacketType.mkchild:
                children.append(self[i][:32])

        return children

    def get_contn(self) -&gt; bytes:
        &#34;&#34;&#34;
        Returns the feed ID of this feed&#39;s continuation feed.
        If this feed has not ended, &#39;None&#39; is returned.
        &#34;&#34;&#34;
        if self.get_pkt_type(-1) == PacketType.contdas:
            return self[-1][:32]
        else:
            return None

    def get_prev(self) -&gt; bytes:
        &#34;&#34;&#34;
        Returns the feed ID of this feed&#39;s predecessor feed.
        If this feed does not have a predecessor, &#39;None&#39; is returned.
        &#34;&#34;&#34;
        if self.anchor_seq != 0:
            return None

        if self.get_pkt_type(1) == PacketType.iscontn:
            return self[1][:32]
        else:
            return None

    def get_front(self) -&gt; tuple[int, bytes]:
        &#34;&#34;&#34;
        Returns this feed&#39;s front sequence number and front message ID
        in a tuple.
        &#34;&#34;&#34;
        assert self.front_mid is not None
        return (self.front_seq, self.front_mid)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="feed.Feed.append_blob"><code class="name flex">
<span>def <span class="ident">append_blob</span></span>(<span>self, payload: bytes) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a blob from the provided payload.
A packet of type 'chain20' is appended to the feed,
referring to the blob files (in _blob directory).
If the feed has ended, nothing is appended and
False is returned.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def append_blob(self, payload: bytes) -&gt; bool:
    &#34;&#34;&#34;
    Creates a blob from the provided payload.
    A packet of type &#39;chain20&#39; is appended to the feed,
    referring to the blob files (in _blob directory).
    If the feed has ended, nothing is appended and
    False is returned.
    &#34;&#34;&#34;
    next_seq = (self.front_seq + 1).to_bytes(4, &#34;big&#34;)
    assert self.front_mid is not None
    assert self.skey is not None, &#34;can only append if signing key is known&#34;
    pkt, blobs = create_chain(self.fid, next_seq,
                              self.front_mid, payload,
                              self.skey)

    if pkt is None:
        return False

    self.append_pkt(pkt)
    return self._write_blob(blobs)</code></pre>
</details>
</dd>
<dt id="feed.Feed.append_bytes"><code class="name flex">
<span>def <span class="ident">append_bytes</span></span>(<span>self, payload: bytes) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a regular packet containing the given payload
and appends it to the feed.
Returns 'True' on success.
If the feed has ended, nothing is appended and
False is returned.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def append_bytes(self, payload: bytes) -&gt; bool:
    &#34;&#34;&#34;
    Creates a regular packet containing the given payload
    and appends it to the feed.
    Returns &#39;True&#39; on success.
    If the feed has ended, nothing is appended and
    False is returned.
    &#34;&#34;&#34;
    next_seq = self.front_seq + 1
    assert self.front_mid is not None
    assert self.skey is not None, &#34;can only append if signing key known&#34;
    pkt = Packet(self.fid, next_seq.to_bytes(4, &#34;big&#34;),
                 self.front_mid, payload, skey=self.skey)
    if pkt is None:
        return False

    return self.append_pkt(pkt)</code></pre>
</details>
</dd>
<dt id="feed.Feed.append_pkt"><code class="name flex">
<span>def <span class="ident">append_pkt</span></span>(<span>self, pkt: packet.Packet) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Appends given packet to .log file and updates
front sequence number and message ID.
Returns 'True' on success.
If the feed has ended, nothing is appended and
False is returned.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def append_pkt(self, pkt: Packet) -&gt; bool:
    &#34;&#34;&#34;
    Appends given packet to .log file and updates
    front sequence number and message ID.
    Returns &#39;True&#39; on success.
    If the feed has ended, nothing is appended and
    False is returned.
    &#34;&#34;&#34;
    if self.has_ended():
        print(&#34;cannot append to finished feed&#34;)
        return False

    # TODO: better error handling
    if pkt is None:
        return False

    # go to end of buffer and write
    assert pkt.wire is not None, &#34;packet must be signed before appended&#34;
    payload = bytes(8) + pkt.wire
    assert len(payload) == 128, &#34;wire pkt must be 128B&#34;

    f = open(self.file_name, &#34;rb+&#34;)
    f.seek(0, 2)
    f.write(payload)  # pappend 8B reserved
    f.close()

    # update header info
    self.front_seq += 1
    self.front_mid = pkt.mid
    self._update_header()
    return True</code></pre>
</details>
</dd>
<dt id="feed.Feed.get"><code class="name flex">
<span>def <span class="ident">get</span></span>(<span>self, i: int) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Returns Packet instance with corresponding sequence number in feed.
Identical to <strong>getitem</strong>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get(self, i: int) -&gt; bytes:
    &#34;&#34;&#34;
    Returns Packet instance with corresponding sequence number in feed.
    Identical to __getitem__.
    &#34;&#34;&#34;
    return self[i]</code></pre>
</details>
</dd>
<dt id="feed.Feed.get_blob_chain"><code class="name flex">
<span>def <span class="ident">get_blob_chain</span></span>(<span>self, pkt: packet.Packet) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieves the full data that a 'chain20' packet is pointing to.
The content is validated.
If validation fails, 'None' is returned.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_blob_chain(self, pkt: Packet) -&gt; bytes:
    &#34;&#34;&#34;
    Retrieves the full data that a &#39;chain20&#39; packet is pointing to.
    The content is validated.
    If validation fails, &#39;None&#39; is returned.
    &#34;&#34;&#34;
    assert pkt.pkt_type == PacketType.chain20, &#34;pkt type must be chain20&#34;

    blobs = []
    ptr = pkt.payload[-20:]
    while ptr != bytes(20):
        blob = self._get_blob(ptr)
        assert blob is not None, &#34;chaining of blobs failed&#34;
        ptr = blob.ptr
        blobs.append(blob)

    return self._verify_chain(pkt, blobs)</code></pre>
</details>
</dd>
<dt id="feed.Feed.get_children"><code class="name flex">
<span>def <span class="ident">get_children</span></span>(<span>self) ‑> list[bytes]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a list of all child feed IDs contained
within this feed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_children(self) -&gt; list[bytes]:
    &#34;&#34;&#34;
    Returns a list of all child feed IDs contained
    within this feed.
    &#34;&#34;&#34;
    children = []
    for i in range(self.anchor_seq + 1, self.front_seq + 1):
        if self.get_pkt_type(i) == PacketType.mkchild:
            children.append(self[i][:32])

    return children</code></pre>
</details>
</dd>
<dt id="feed.Feed.get_contn"><code class="name flex">
<span>def <span class="ident">get_contn</span></span>(<span>self) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the feed ID of this feed's continuation feed.
If this feed has not ended, 'None' is returned.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_contn(self) -&gt; bytes:
    &#34;&#34;&#34;
    Returns the feed ID of this feed&#39;s continuation feed.
    If this feed has not ended, &#39;None&#39; is returned.
    &#34;&#34;&#34;
    if self.get_pkt_type(-1) == PacketType.contdas:
        return self[-1][:32]
    else:
        return None</code></pre>
</details>
</dd>
<dt id="feed.Feed.get_front"><code class="name flex">
<span>def <span class="ident">get_front</span></span>(<span>self) ‑> tuple[int, bytes]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns this feed's front sequence number and front message ID
in a tuple.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_front(self) -&gt; tuple[int, bytes]:
    &#34;&#34;&#34;
    Returns this feed&#39;s front sequence number and front message ID
    in a tuple.
    &#34;&#34;&#34;
    assert self.front_mid is not None
    return (self.front_seq, self.front_mid)</code></pre>
</details>
</dd>
<dt id="feed.Feed.get_parent"><code class="name flex">
<span>def <span class="ident">get_parent</span></span>(<span>self) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the feed ID of this feed's parent feed.
If this is not a child feed, 'None' is returned.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_parent(self) -&gt; bytes:
    &#34;&#34;&#34;
    Returns the feed ID of this feed&#39;s parent feed.
    If this is not a child feed, &#39;None&#39; is returned.
    &#34;&#34;&#34;
    if self.anchor_seq != 0:
        return None

    if self.get_pkt_type(1) != PacketType.ischild:
        return None

    # parent fid == first 32B of payload in first pkt
    return self[1][:32]</code></pre>
</details>
</dd>
<dt id="feed.Feed.get_pkt_type"><code class="name flex">
<span>def <span class="ident">get_pkt_type</span></span>(<span>self, seq: int) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the type of the packet with given index.
Bytes can be compared with PacketTypes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_pkt_type(self, seq: int) -&gt; bytes:
    &#34;&#34;&#34;
    Returns the type of the packet with given index.
    Bytes can be compared with PacketTypes.
    &#34;&#34;&#34;
    raw_pkt = self.get_raw_pkt(seq)
    pkt_type = raw_pkt[7:8]
    types = [PacketType.chain20, PacketType.contdas, PacketType.ischild,
             PacketType.mkchild]
    try:
        return types[types.index(pkt_type)]
    except Exception:
        return None</code></pre>
</details>
</dd>
<dt id="feed.Feed.get_prev"><code class="name flex">
<span>def <span class="ident">get_prev</span></span>(<span>self) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the feed ID of this feed's predecessor feed.
If this feed does not have a predecessor, 'None' is returned.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_prev(self) -&gt; bytes:
    &#34;&#34;&#34;
    Returns the feed ID of this feed&#39;s predecessor feed.
    If this feed does not have a predecessor, &#39;None&#39; is returned.
    &#34;&#34;&#34;
    if self.anchor_seq != 0:
        return None

    if self.get_pkt_type(1) == PacketType.iscontn:
        return self[1][:32]
    else:
        return None</code></pre>
</details>
</dd>
<dt id="feed.Feed.get_raw_pkt"><code class="name flex">
<span>def <span class="ident">get_raw_pkt</span></span>(<span>self, seq: int) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the raw packet as bytes.
The raw packet consists of 8B placeholder and 120B packet wire format.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_raw_pkt(self, seq: int) -&gt; bytes:
    &#34;&#34;&#34;
    Returns the raw packet as bytes.
    The raw packet consists of 8B placeholder and 120B packet wire format.
    &#34;&#34;&#34;
    if seq &lt; 0:
        seq = self.front_seq + seq + 1  # access last pkt through -1 etc.
    if seq &gt; self.front_seq or seq &lt;= self.anchor_seq:
        raise IndexError

    relative_i = seq- self.anchor_seq
    f = open(self.file_name, &#34;rb&#34;)
    f.seek(128 * relative_i)
    raw_pkt = f.read(128)[8:]  # cut off reserved 8B
    f.close()

    return raw_pkt</code></pre>
</details>
</dd>
<dt id="feed.Feed.has_ended"><code class="name flex">
<span>def <span class="ident">has_ended</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Returns 'True' if the feed was ended by a 'contdas' packet.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def has_ended(self) -&gt; bool:
    &#34;&#34;&#34;
    Returns &#39;True&#39; if the feed was ended by a &#39;contdas&#39; packet.
    &#34;&#34;&#34;
    if len(self) &lt; 1:
        return False
    return self.get_pkt_type(-1) == PacketType.contdas</code></pre>
</details>
</dd>
<dt id="feed.Feed.verify_and_append_bytes"><code class="name flex">
<span>def <span class="ident">verify_and_append_bytes</span></span>(<span>self, raw_pkt: bytes) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a new packet from the raw bytes and attempts to validate it.
Uses the feed_id as validation key.
If the packet does not validate, False is returned.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def verify_and_append_bytes(self, raw_pkt: bytes) -&gt; bool:
    &#34;&#34;&#34;
    Creates a new packet from the raw bytes and attempts to validate it.
    Uses the feed_id as validation key.
    If the packet does not validate, False is returned.
    &#34;&#34;&#34;
    seq = (self.front_seq + 1).to_bytes(4, &#34;big&#34;)
    assert self.front_mid is not None
    pkt = pkt_from_bytes(self.fid, seq, self.front_mid, raw_pkt)

    if pkt is None:
        return False

    return self.append_pkt(pkt)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="feed.Feed" href="#feed.Feed">Feed</a></code></h4>
<ul class="">
<li><code><a title="feed.Feed.append_blob" href="#feed.Feed.append_blob">append_blob</a></code></li>
<li><code><a title="feed.Feed.append_bytes" href="#feed.Feed.append_bytes">append_bytes</a></code></li>
<li><code><a title="feed.Feed.append_pkt" href="#feed.Feed.append_pkt">append_pkt</a></code></li>
<li><code><a title="feed.Feed.get" href="#feed.Feed.get">get</a></code></li>
<li><code><a title="feed.Feed.get_blob_chain" href="#feed.Feed.get_blob_chain">get_blob_chain</a></code></li>
<li><code><a title="feed.Feed.get_children" href="#feed.Feed.get_children">get_children</a></code></li>
<li><code><a title="feed.Feed.get_contn" href="#feed.Feed.get_contn">get_contn</a></code></li>
<li><code><a title="feed.Feed.get_front" href="#feed.Feed.get_front">get_front</a></code></li>
<li><code><a title="feed.Feed.get_parent" href="#feed.Feed.get_parent">get_parent</a></code></li>
<li><code><a title="feed.Feed.get_pkt_type" href="#feed.Feed.get_pkt_type">get_pkt_type</a></code></li>
<li><code><a title="feed.Feed.get_prev" href="#feed.Feed.get_prev">get_prev</a></code></li>
<li><code><a title="feed.Feed.get_raw_pkt" href="#feed.Feed.get_raw_pkt">get_raw_pkt</a></code></li>
<li><code><a title="feed.Feed.has_ended" href="#feed.Feed.has_ended">has_ended</a></code></li>
<li><code><a title="feed.Feed.verify_and_append_bytes" href="#feed.Feed.verify_and_append_bytes">verify_and_append_bytes</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>